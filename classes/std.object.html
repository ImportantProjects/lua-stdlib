<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>stdlib</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Methods">Methods </a></li>
</ul>


<h2>Classes</h2>
<ul class="nowrap">
  <li><a href="../classes/std.list.html">std.list</a></li>
  <li><strong>std.object</strong></li>
  <li><a href="../classes/std.set.html">std.set</a></li>
  <li><a href="../classes/std.strbuf.html">std.strbuf</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/std.html">std</a></li>
  <li><a href="../modules/std.debug.html">debug</a></li>
  <li><a href="../modules/std.functional.html">functional</a></li>
  <li><a href="../modules/std.getopt.html">getopt</a></li>
  <li><a href="../modules/std.io.html">io</a></li>
  <li><a href="../modules/std.math.html">math</a></li>
  <li><a href="../modules/std.package.html">package</a></li>
  <li><a href="../modules/std.strict.html">strict</a></li>
  <li><a href="../modules/std.string.html">string</a></li>
  <li><a href="../modules/std.table.html">table</a></li>
  <li><a href="../modules/std.tree.html">tree</a></li>
</ul>

</div>

<div id="content">

<h1>Class <code>std.object</code></h1>

<p>Prototype-based objects.</p>
<p>


<p> This module creates the root prototype object from which every other
 object is descended.  There are no classes as such, rather new objects
 are created by cloning an existing prototype object, and then changing
 or adding to it. Further objects can then be made by cloning the changed
 object, and so on.</p>

<p> Objects are cloned by simply calling an existing object which then
 serves as a prototype, from which the new object is copied.</p>

<p> All valid objects contain a field <code>_init</code>, which determines the syntax
 required to execute the cloning process:</p>

<ol>
    <li><p><code>_init</code> can be a list of keys; then the unnamed <code>init_1</code> through
  <code>init_n</code> values from the argument table are assigned to the
  corresponding keys in <code>new_object</code>;</p>

<pre><code> new_object = prototype {
   init_1, ..., init_m;
   field_1 = value_1,
   ...
   field_n = value_n,
 }
</code></pre></li>
    <li><p>Or it can be a function, in which the arguments passed to the
  prototype during cloning are simply handed to the <code>_init</code> function:</p>

<pre><code>new_object = prototype (value, ...)
</code></pre></li>
</ol>

<p> Field names beginning with "_" are <em>private</em>, and moved into the object
 metatable during cloning. Unless <code>new_object</code> changes the metatable this
 way, then it will share a metatable with <code>prototype</code> for efficiency.</p>

<p> Objects, then, are essentially tables of <code>field_n = value_n</code> pairs:</p>

<ul>
    <li>Access an object field: <code>object.field</code></li>
    <li>Call an object method: <code>object:method (...)</code></li>
    <li>Call a "class" method: <code>Class.method (object, ...)</code></li>
    <li>Add a field: <code>object.field = x</code></li>
    <li>Add a method: <code>function object:method (...) ... end</code></li>
</ul>

</p>


<h2><a href="#Methods">Methods </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#std.object.__tostring">std.object.__tostring</a></td>
	<td class="summary">Return a string representation of <em>object</em>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.object.__totable">std.object.__totable</a></td>
	<td class="summary">Return a shallow copy of non-private object fields.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.object:clone">std.object:clone (prototype, ...)</a></td>
	<td class="summary">Clone an object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.object:tostring">std.object:tostring (o)</a></td>
	<td class="summary">Return a stringified version of the contents of object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.object:totable">std.object:totable (o)</a></td>
	<td class="summary">Return a new table with a shallow copy of all non-private fields
 in object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#std.object:type">std.object:type (o)</a></td>
	<td class="summary">Return the extended object type, if any, else primitive type.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Methods"></a>Methods </h2>

    <dl class="function">
    <dt>
    <a name = "std.object.__tostring"></a>
    <strong>std.object.__tostring</strong>
    </dt>
    <dd>
    Return a string representation of <em>object</em>.




    <h3>See also:</h3>
    <ul>
         <a href="../classes/std.object.html#std.object:tostring">std.object:tostring</a>
    </ul>


</dd>
    <dt>
    <a name = "std.object.__totable"></a>
    <strong>std.object.__totable</strong>
    </dt>
    <dd>
    Return a shallow copy of non-private object fields. </p>

<p> This pseudo-metamethod is used during object cloning to make the
 intial new object table, and can be overridden in other objects
 for greater control of which fields are considered non-private.




    <h3>See also:</h3>
    <ul>
         <a href="../classes/std.object.html#std.object:totable">std.object:totable</a>
    </ul>


</dd>
    <dt>
    <a name = "std.object:clone"></a>
    <strong>std.object:clone (prototype, ...)</strong>
    </dt>
    <dd>
    Clone an object. </p>

<p> Prototypes are cloned by calling directly as described above, so this
 <code>clone</code> method is rarely used explicitly.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">prototype</span>
            <span class="types"><a class="type" href="../classes/std.object.html#">std.object</a></span>
         source object
        </li>
        <li><span class="parameter">...</span>

<pre><code>   arguments
</code></pre>

        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="../classes/std.object.html#">std.object</a></span>
        a clone of <code>prototype</code>, adjusted
 according to the rules above, and sharing a metatable where possible.
    </ol>




</dd>
    <dt>
    <a name = "std.object:tostring"></a>
    <strong>std.object:tostring (o)</strong>
    </dt>
    <dd>
    Return a stringified version of the contents of object. </p>

<p> First the object type, and then between { and } a list of the array
 part of the object table (without numeric keys) followed by the
 remaining key-value pairs.</p>

<p> This function doesn't recurse explicity, but relies upon suitable
 <code>__tostring</code> metamethods in contained objects.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">o</span>
            <span class="types"><a class="type" href="../classes/std.object.html#">std.object</a></span>
          an object
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        stringified object representation
    </ol>




</dd>
    <dt>
    <a name = "std.object:totable"></a>
    <strong>std.object:totable (o)</strong>
    </dt>
    <dd>
    Return a new table with a shallow copy of all non-private fields
 in object. </p>

<p> Where private fields have keys prefixed with "_".

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">o</span>
            <span class="types"><a class="type" href="../classes/std.object.html#">std.object</a></span>
          an object
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
        raw (non-object) table of object fields
    </ol>




</dd>
    <dt>
    <a name = "std.object:type"></a>
    <strong>std.object:type (o)</strong>
    </dt>
    <dd>

<p>Return the extended object type, if any, else primitive type. </p>

<p> It's conventional to organise similar objects according to a string
 valued <code>_type</code> field, which can then be queried using this function.</p>

<pre><code> Stack = Object {
   _type = "Stack",

   __tostring = function (self) ... end,

   __index = {
     push = function (self) ... end,
     pop  = function (self) ... end,
   },
 }
 stack = Stack {}

 stack:type () --&gt; "Stack"
</code></pre>



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">o</span>
            <span class="types"><a class="type" href="../classes/std.object.html#">std.object</a></span>
          an object
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        type of the object
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.0</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
