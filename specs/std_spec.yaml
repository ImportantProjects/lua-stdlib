before: |
  this_module   = "std"
  global_table  = "_G"

  exported_apis = { 1, "assert", "barrel", "elems", "eval", "getmetamethod",
                    "ielems", "ipairs", "ireverse", "lambda", "monkey_patch",
                    "pairs", "require", "ripairs", "tostring", "version" }

  -- Tables with iterator metamethods used by various examples.
  __pairs = setmetatable ({ content = "a string" }, {
              __pairs = function (t)
                          return function (x, n)
                            if n < #x.content then
                              return n+1, string.sub (x.content, n+1, n+1)
                            end
                          end, t, 0
                        end,
            })
  __index = setmetatable ({ content = "a string" }, {
              __index = function (t, n)
                          if n <= #t.content then
                            return t.content:sub (n, n)
                          end
                        end,
              __len   = function (t) return #t.content end,
            })

  M = require (this_module)

specify std:
- context when required:
  - it does not touch the global table:
      expect (show_apis {added_to=global_table, by=this_module}).
        to_equal {}
  - it exports the documented apis:
      t = {}
      for k in pairs (M) do t[#t + 1] = k end
      expect (t).to_contain.a_permutation_of (exported_apis)

- context when lazy loading:
  - it has no submodules on initial load:
      for _, v in pairs (M) do
        expect (type (v)).not_to_be "table"
      end
  - it loads submodules on demand:
      lazy = M.set
      expect (lazy).to_be (require "std.set")
  - it loads submodule functions on demand:
      expect (M.object.prototype (M.set {"Lazy"})).
        to_be "Set"

- describe assert:
  - before:
      fname = "assert"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses wrong argument types:
      expect (f (false, false)).to_error (msg (2, "string or nil", "boolean"))

  - context when it does not trigger:
    - it has a truthy initial argument:
        expect (f (1)).not_to_error ()
        expect (f (true)).not_to_error ()
        expect (f "yes").not_to_error ()
        expect (f (false == false)).not_to_error ()
    - it returns the initial argument:
        expect (f (1)).to_be (1)
        expect (f (true)).to_be (true)
        expect (f "yes").to_be "yes"
        expect (f (false == false)).to_be (true)
  - context when it triggers:
    - it has a falsey initial argument:
        expect (f ()).to_error ()
        expect (f (false)).to_error ()
        expect (f (1 == 0)).to_error ()
    - it throws an optional error string:
        expect (f (false, "ah boo")).to_error "ah boo"
    - it plugs specifiers with string.format: |
        expect (f (nil, "%s %d: %q", "here", 42, "a string")).
          to_error (string.format ("%s %d: %q", "here", 42, "a string"))


- describe barrel:
  - before:
      io_mt = {}
      t = {
        io = {
          stdin  = setmetatable ({}, io_mt),
          stdout = setmetatable ({}, io_mt),
          stderr = setmetatable ({}, io_mt),
        },
        math = {},
        table = {},
      }

      fname = "barrel"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

      f (t)

  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it installs std.io monkey patches:
      expect (io_mt.readlines).to_be (M.io.readlines)
      expect (io_mt.writelines).to_be (M.io.writelines)
  - it installs std.lua monkey patches:
      expect (t.assert).to_be (M.assert)
      expect (t.elems).to_be (M.elems)
      expect (t.eval).to_be (M.eval)
      expect (t.ielems).to_be (M.ielems)
      expect (t.ipairs).to_be (M.ipairs)
      expect (t.lambda).to_be (M.lambda)
      expect (t.pairs).to_be (M.pairs)
      expect (t.require).to_be (M.require)
  - it installs std.math monkey patches:
      expect (t.math.floor).to_be (M.math.floor)
  - it installs std.string monkey patches:
      # FIXME: string metatable monkey-patches leak out!
      mt = getmetatable ""
      expect (mt.__append).to_be (M.string.__append)
      expect (mt.__concat).to_be (M.string.__concat)
      expect (mt.__index).to_be (M.string.__index)
  - it installs std.table monkey patches:
      expect (t.table.sort).to_be (M.table.sort)
  - it scribbles into the supplied namespace:
      expect (t).should_equal {
        assert          = M.assert,
        bind            = M.functional.bind,
        case            = M.case,
        collect         = M.functional.collect,
        compose         = M.functional.compose,
        curry           = M.functional.curry,
        die             = M.io.die,
        elems           = M.elems,
        eval            = M.eval,
        filter          = M.functional.filter,
        fold            = M.functional.reduce,
        getmetamethod   = M.getmetamethod,
        id              = M.functional.id,
        ielems          = M.ielems,
        ileaves         = M.tree.ileaves,
        inodes          = M.tree.inodes,
        io              = t.io,
        ipairs          = M.ipairs,
        ireverse        = M.ireverse,
        lambda          = M.lambda,
        leaves          = M.tree.leaves,
        map             = M.functional.map,
        math            = t.math,
        metamethod      = M.table.metamethod,
        nodes           = M.tree.nodes,
        op              = M.functional.op,
        pack            = M.table.pack,
        pairs           = M.pairs,
        pickle          = M.string.pickle,
        prettytostring  = M.string.prettytostring,
        render          = M.string.render,
        require         = M.require,
        require_version = M.string.require_version,
        ripairs         = M.ripairs,
        table           = t.table,
        tostring        = M.tostring,
        totable         = M.table.totable,
        warn            = M.io.warn,
      }

- describe elems:
  - before:
      fname = "elems"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it is an iterator over table values:
      t = {}
      for e in f {"foo", bar = "baz", 42} do
        t[#t + 1] = e
      end
      expect (t).to_contain.a_permutation_of {"foo", "baz", 42}
  - it respects __pairs metamethod: |
      t = {}
      for v in f (__pairs) do t[#t + 1] = v end
      expect (t).
        to_contain.a_permutation_of {"a", " ", "s", "t", "r", "i", "n", "g"}
  - it works for an empty list:
      t = {}
      for e in f {} do t[#t + 1] = e end
      expect (t).to_equal {}


- describe eval:
  - before:
      fname = "eval"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
  - it diagnoses too many arguments:
      expect (f ("1", false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it diagnoses invalid lua:
      # Some internal error when eval tries to call uncompilable "=" code.
      expect (f "=").to_error ()
  - it evaluates a string of lua code:
      expect (f "math.pow (2, 10)").to_be (math.pow (2, 10))


- describe getmetamethod:
  - before:
      fname = "getmetamethod"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "object or table"))
      expect (f ({})).to_error (msg (2, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "object or table", "boolean"))
      expect (f ({}, false)).to_error (msg (2, "string", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, "foo", false)).
       to_error (toomanyarg (this_module, fname, 2, 3))

  - context with a table:
    - before:
        method = function () end
        t = setmetatable ({}, { _type = "table", _method = method })
    - it returns nil for missing metamethods:
        expect (f (t, "not a metamethod on t")).to_be (nil)
    - it returns nil for non-function metatable entries:
        expect (f (t, "_type")).to_be (nil)
    - it returns a method from the metatable:
        expect (f (t, "_method")).to_be (method)

  - context with an object:
    - before:
        Object = require "std.object"
        objmethod = function () end
        obj = Object {
          _type = "DerivedObject",
          _method = objmethod,
        }
    - it returns nil for missing metamethods:
        expect (f (obj, "not a metamethod on obj")).to_be (nil)
    - it returns nil for non-function metatable entries:
        expect (f (obj, "_type")).to_be (nil)
    - it returns a method from the metatable:
        expect (f (obj, "_method")).to_be (objmethod)


- describe ielems:
  - before:
      fname = "ielems"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it is an iterator over integer-keyed table values:
      t = {}
      for e in f {"foo", 42} do
        t[#t + 1] = e
      end
      expect (t).to_equal {"foo", 42}
  - it ignores the dictionary part of a table:
      t = {}
      for e in f {"foo", 42; bar = "baz", qux = "quux"} do
        t[#t + 1] = e
      end
      expect (t).to_equal {"foo", 42}
  - it respects __len metamethod:
      t = {}
      for v in f (__index) do t[#t + 1] = v end
      expect (t).to_equal {"a", " ", "s", "t", "r", "i", "n", "g"}
  - it works for an empty list:
      t = {}
      for e in f {} do t[#t + 1] = e end
      expect (t).to_equal {}


- describe ipairs:
  - before:
      fname = "ipairs"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it is an iterator over integer-keyed table values:
      t = {}
      for i, v in f {"foo", 42} do
        t[i] = v
      end
      expect (t).to_equal {"foo", 42}
  - it ignores the dictionary part of a table:
      t = {}
      for i, v in f {"foo", 42; bar = "baz", qux = "quux"} do
        t[i] = v
      end
      expect (t).to_equal {"foo", 42}
  - it respects __len metamethod:
      t = {}
      for k, v in f (__index) do t[k] = v end
      expect (t).to_equal {"a", " ", "s", "t", "r", "i", "n", "g"}
  - it works for an empty list:
      t = {}
      for i, v in f {} do t[i] = v end
      expect (t).to_equal {}


- describe ireverse:
  - before:
      fname = "ireverse"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it returns a new list:
      t = {1, 2, 5}
      expect (f (t)).not_to_be (t)
  - it reverses the elements relative to the original list:
      expect (f {1, 2, "five"}).to_equal {"five", 2, 1}
  - it ignores the dictionary part of a table:
      expect (f {1, 2, "five"; a = "b", c = "d"}).to_equal {"five", 2, 1}
  - it respects __len metamethod:
      expect (f (__index)).to_equal {"g", "n", "i", "r", "t", "s", " ", "a"}
  - it works for an empty list:
      expect (f {}).to_equal {}


- describe lambda:
  - before:
      fname = "lambda"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong arguments types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
  - it diagnoses too many arguments:
      expect (f ("foo", false)).to_error (toomanyarg (this_module, fname, 1, 2))
  - it diagnoses bad lambda string:
      expect (select (2, f "foo")).to_be "invalid lambda string 'foo'"
  - it diagnoses an uncompilable expression:
      expect (select (2, f "||+")).to_be "invalid lambda string '||+'"
      expect (select (2, f "=")).to_be "invalid lambda string '='"

  - context with argument format:
    - it returns a function:
        expect (prototype (f "|x| 1+x")).to_be "function"
    - it compiles to a working Lua function:
        fn = f "||42"
        expect (fn ()).to_be (42)
    - it propagates argument values:
        fn = f "|...| {...}"
        expect (fn (1,2,3)).to_equal {1,2,3}
  - context with expression format:
    - it returns a function:
        expect (prototype (f "=1")).to_be "function"
    - it compiles to a working Lua function:
        fn = f "=42"
        expect (fn ()).to_be (42)
    - it sets auto-argument values:
        fn = f "=_1*_1"
        expect (fn (42)).to_be (1764)


- describe monkey_patch:
  - before:
      io_mt = {}
      t = {
        io = {
          stdin  = setmetatable ({}, io_mt),
          stdout = setmetatable ({}, io_mt),
          stderr = setmetatable ({}, io_mt),
        },
        math = {},
        table = {},
      }

      fname = "monkey_patch"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

      f (t)

  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it installs std module functions:
      for _, v in ipairs (exported_apis) do
        if type (M[v]) == "function" and v ~= "barrel" and v ~= "monkey_patch" then
          expect (t[v]).to_be (M[v])
        end
      end


- describe pairs:
  - before:
      fname = "pairs"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it is an iterator over all table values:
      t = {}
      for k, v in f {"foo", bar = "baz", 42} do
        t[k] = v
      end
      expect (t).to_equal {"foo", bar = "baz", 42}
  - it respects __pairs metamethod: |
      t = {}
      for k, v in f (__pairs) do t[k] = v end
      expect (t).
        to_contain.a_permutation_of {"a", " ", "s", "t", "r", "i", "n", "g"}
  - it works for an empty list:
      t = {}
      for k, v in f {} do t[k] = v end
      expect (t).to_equal {}


- describe require:
  - before:
      fname = "require"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
      expect (f ("module", false)).to_error (msg (2, "string or nil", "boolean"))
      expect (f ("module", "min", false)).
        to_error (msg (3, "string or nil", "boolean"))
      expect (f ("module", "min", "too_big", false)).
        to_error (msg (4, "string or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f ("module", "min", "too_big", "pattern", false)).
        to_error (toomanyarg (this_module, fname, 4, 5))

  - it diagnoses non-existent module:
      expect (f ("module-not-exists", "", "")).to_error "module-not-exists"
  - it diagnoses module too old:
      expect (f ("std", "9999", "9999")).to_error ()
  - it diagnoses module too new:
      expect (f ("std", "0", "0")).to_error ()
  - context when the module version is compatible:
    - it returns the module table:
        expect (f ("std", "0", "9999")).to_be (require "std")
    - it places no upper bound by default:
        expect (f ("std", "41")).to_be (require "std")
    - it places no lower bound by default:
        expect (f "std").to_be (require "std")
    - it uses _VERSION when version field is nil:
        std = require "std"
        M._VERSION, M.version = M.version, M._VERSION
        expect (f ("std", "41", "9999")).to_be (require "std")
        M._VERSION, M.version = M.version, M._VERSION
  - context with semantic versioning:
    - before:
        std = require "std"
        ver = std.version
        std.version = "1.2.3"
    - after:
        std.version = ver
    - it diagnoses module too old:
        expect (f ("std", "1.2.4")).to_error ()
        expect (f ("std", "1.3")).to_error ()
        expect (f ("std", "2.1.2")).to_error ()
        expect (f ("std", "2")).to_error ()
        expect (f ("std", "1.2.10")).to_error ()
    - it diagnoses module too new:
        expect (f ("std", nil, "1.2.2")).to_error ()
        expect (f ("std", nil, "1.1")).to_error ()
        expect (f ("std", nil, "1.1.2")).to_error ()
        expect (f ("std", nil, "1")).to_error ()
    - it returns modules with version in range:
        expect (f ("std")).to_be (std)
        expect (f ("std", "1")).to_be (std)
        expect (f ("std", "1.2.3")).to_be (std)
        expect (f ("std", nil, "2")).to_be (std)
        expect (f ("std", nil, "1.3")).to_be (std)
        expect (f ("std", nil, "1.2.10")).to_be (std)
        expect (f ("std", "1.2.3", "1.2.4")).to_be (std)
  - context with several numbers in version string:
    - before:
        std = require "std"
        ver = std.version
        std.version = "standard library for Lua 5.2 / 41"
    - after:
        std.version = ver
    - it diagnoses module too old:
        expect (f ("std", "42")).to_error ()
    - it diagnoses module too new:
        expect (f ("std", nil, "40")).to_error ()
    - it returns modules with version in range:
        expect (f ("std")).to_be (std)
        expect (f ("std", "1")).to_be (std)
        expect (f ("std", "41")).to_be (std)
        expect (f ("std", nil, "42")).to_be (std)
        expect (f ("std", "41", "42")).to_be (std)


- describe ripairs:
  - before:
      fname = "ripairs"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).
        to_error (toomanyarg (this_module, fname, 1, 2))

  - it returns a function, the table and a number:
      fn, t, i = f {1, 2, 3}
      expect ({type (fn), t, type (i)}).to_equal {"function", {1, 2, 3}, "number"}
  - it iterates over the array part of a table:
      t, u = {1, 2, 3; a=4, b=5, c=6}, {}
      for i, v in f (t) do u[i] = v end
      expect (u).to_equal {1, 2, 3}
  - it returns elements in reverse order:
      t, u = {"one", "two", "five"}, {}
      for _, v in f (t) do u[#u + 1] = v end
      expect (u).to_equal {"five", "two", "one"}
  - it respects __len metamethod:
      t = {}
      for i, v in f (__index) do t[i] = v end
      expect (t).to_equal {"a", " ", "s", "t", "r", "i", "n", "g"}
      t = {}
      for _, v in f (__index) do t[#t + 1] = v end
      expect (t).to_equal {"g", "n", "i", "r", "t", "s", " ", "a"}
  - it works with the empty list:
      t = {}
      for k, v in f {} do t[k] = v end
      expect (t).to_equal {}


- describe tostring:
  - before:
      fname = "tostring"
      f = M[fname]

  - it diagnoses too many arguments:
      expect (f (true, false)).
        to_error (toomanyarg (this_module, fname, 1, 2))

  - it renders primitives exactly like system tostring:
      expect (f (nil)).to_be (tostring (nil))
      expect (f (false)).to_be (tostring (false))
      expect (f (42)).to_be (tostring (42))
      expect (f (f)).to_be (tostring (f))
      expect (f "a string").to_be "a string"
  - it renders empty tables as a pair of braces:
      expect (f {}).to_be ("{}")
  - it renders table array part compactly:
      expect (f {"one", "two", "five"}).
        to_be '{1=one,2=two,3=five}'
  - it renders a table dictionary part compactly:
      expect (f { one = true, two = 2, three = {3}}).
        to_be '{one=true,three={1=3},two=2}'
  - it renders table keys in table.sort order:
      expect (f { one = 3, two = 5, three = 4, four = 2, five = 1 }).
        to_be '{five=1,four=2,one=3,three=4,two=5}'
  - it renders keys with invalid symbol names compactly:
      expect (f { _ = 0, word = 0, ["?"] = 1, ["a-key"] = 1, ["[]"] = 1 }).
        to_be '{?=1,[]=1,_=0,a-key=1,word=0}'
