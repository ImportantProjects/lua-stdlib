before:
  base = require "std.base"

  this_module  = "std.functional"
  global_table = "_G"

  exported_apis = { "bind", "callable", "case", "collect", "compose",
                    "cond", "curry", "eval", "filter", "fold", "foldl",
                    "foldr", "id", "lambda", "map", "map_with",
                    "memoize", "nop", "op", "reduce", "zip", "zip_with" }

  M = require (this_module)

specify std.functional:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}
  - it exports the documented apis:
      t = {}
      for k in pairs (M) do t[#t + 1] = k end
      expect (t).to_contain.a_permutation_of (exported_apis)

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}


- describe bind:
  - before:
      fname = "bind"
      f, badarg = init (M, this_module,  fname)

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))

  - it writes an argument passing deprecation warning on first call:
        expect (capture (f, {init, M, fname})).
          to_contain_error "was deprecated"
        expect (capture (f, {init, M, fname})).
          not_to_contain_error "was deprecated"

  - it does not affect normal operation if no arguments are bound:
      expect (f (math.min, {}) (2, 3, 4)).to_be (2)
  - it takes the extra arguments into account:
      expect (f (math.min, {1, 0}) (2, 3, 4)).to_be (0)
  - it appends final call arguments:
      expect (f (math.max, {2, 3}) (4, 5, 1)).to_be (5)
  - it does not require all arguments in final call:
      div = function (a, b) return a / b end
      expect (f (div, {100}) (25)).to_be (4)
  - it supports out of order extra arguments:
      expect (f (math.pow, {[2] = 3}) (2)).to_be (8)
  - it supports the legacy api:
      expect (f (math.min) (2, 3, 4)).to_be (2)
      expect (f (math.min, 1, 0) (2, 3, 4)).to_be (0)
      expect (f (math.pow, nil, 3) (2)).to_be (8)


- describe callable:
  - before:
      f = M.callable
  - it returns the function associated with a callable:
      Container = require "std.container" { __call = M.nop }
      for _, v in ipairs {
        true,
        42,
        "str",
        io.stderr,
        {},
        M.nop,
        setmetatable ({}, {__call = M.nop}),
        Container,
      } do
        expect (f (v)).to_be (pcall (v, {}) and M.nop or nil)
      end

- describe case:
  - before:
      yes     = function ()  return true end
      no      = function ()  return false end
      default = function (s) return s end
      branches = { yes = yes, no = no, default }

      f, badarg = init (M, this_module,  "case")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (2, "non-empty table"))
  - it diagnoses wrong argument types:
      expect (f ("no", false)).
        to_raise (badarg (2, "non-empty table", "boolean"))
  - it diagnoses too many arguments:
      expect (f (1, {2}, false)).to_raise (badarg (3))

  - it matches against branch keys:
      expect (f ("yes", branches)).to_be (true)
      expect (f ("no",  branches)).to_be (false)
  - it has a default for unmatched keys:
      expect (f ("none", branches)).to_be "none"
  - it returns nil for unmatched keys with no default:
      expect (f ("none", { yes = yes, no = no })).to_be (nil)
  - it returns non-function matches:
      expect (f ("t", {t = true})).to_be (true)
  - it evaluates returned functions:
      expect (f ("fn", {fn = function () return true end})).
        to_be (true)
  - it passes 'with' to function matches:
      expect (f ("with", {function (s) return s end})).to_be "with"
  - it evaluates returned functables:
      functable = setmetatable ({}, {__call = function (t, with) return with end})
      expect (f ("functable", {functable})).to_be "functable"
  - it evaluates 'with` exactly once:
      s = "prince"
      function acc () s = s .. "s"; return s end
      expect (f (acc (), {
        prince   = function () return "one" end,
        princes  = function () return "many" end,
        princess = function () return "one" end,
                   function () return "gibberish" end,
      })).to_be "many"


- describe collect:
  - before:
      f, badarg = init (M, this_module,  "collect")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function or any value"))

  - it collects a list of single return value iterator results:
      expect (f (base.ielems, {"a", "b", "c"})).to_equal {"a", "b", "c"}
  - it collects a table of key:value iterator results:
      t = {"first", second="two", last=3}
      expect (f (pairs, t)).to_equal (t)
  - it defaults to ipairs iteration:
      expect (f {1, 2, [5]=5, a="b", c="d"}).to_equal {1, 2}


- describe compose:
  - before:
      f, badarg = init (M, this_module,  "compose")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))
      expect (f (f, false)).to_raise (badarg (2, "function", "boolean"))

  - it composes a single function correctly:
      expect (f (M.id) (1)).to_be (1)
  - it composes functions in the correct order:
      expect (f (math.sin, math.cos) (1)).
        to_be (math.cos (math.sin (1)))


- describe cond:
  - before:
      yes     = function ()  return true end
      no      = function ()  return false end
      default = function (s) return s end
      branches = { yes = yes, no = no, default }

      f = M.cond

  - it returns nil for no arguments:
      expect (f ()).to_be (nil)
  - it evaluates a single function argument:
      expect (f (function () return true end)).to_be (true)
  - it evaluates a single functable argument:
      functable = setmetatable ({}, {__call = function () return true end})
      expect (f (functable)).to_be (true)
  - it returns a non-callable single argument directly:
      expect (f "foo").to_be "foo"
  - it evaluates a branch function if expr is truthy:
      expect (f ("truthy", function (s) return s end)).to_be "truthy"
  - it returns nil if the last expr is falsey:
      expect (f (nil, function (s) return "falsey" end)).to_be (nil)
      expect (f (false, true, false, true)).to_be (nil)
  - it recurses with remaining arguments if first argument is falsey:
      expect (f (nil, true, 42, M.id)).to_be (42)
      expect (f (nil, true, false, false, 42, M.id)).to_be (42)


- describe curry:
  - before:
      f, badarg = init (M, this_module,  "curry")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
      expect (f (f)).to_raise (badarg (2, "int"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))
      expect (f (f, 1.234)).to_raise (badarg (2, "int", "number"))
  - it diagnoses too many arguments:
      expect (f (f, 2, false)).to_raise (badarg (3))

  - it returns a zero argument function uncurried:
      expect (f (f, 0)).to_be (f)
  - it returns a one argument function uncurried:
      expect (f (f, 1)).to_be (f)
  - it curries a two argument function:
      expect (f (f, 2)).not_to_be (f)
  - it evaluates intermediate arguments one at a time:
      expect (f (math.min, 3) (2) (3) (4)).to_equal (2)
  - it returns a curried function that can be partially applied:
      bin = f (math.pow, 2) (2)
      expect (bin (2)).to_be (math.pow (2, 2))
      expect (bin (10)).to_be (math.pow (2, 10))


- describe eval:
  - before:
      f = M.eval

  - it writes a deprecation warning on first call:
      expect (capture (f, {"42"})).to_contain_error "was deprecated"
      expect (capture (f, {"42"})).not_to_contain_error "was deprecated"

  - it diagnoses invalid lua:
      # Some internal error when eval tries to call uncompilable "=" code.
      expect (f "=").to_raise ()
  - it evaluates a string of lua code:
      expect (f "math.pow (2, 10)").to_be (math.pow (2, 10))


- describe filter:
  - before:
     elements = {"a", "b", "c", "d", "e"}
     inverse  = require "std.table".invert (elements)

     f, badarg = init (M, this_module,  "filter")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
      expect (f (f)).to_raise (badarg (2, "function or any value"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))

  - it works with an empty table:
      expect (f (M.id, pairs, {})).to_equal {}
  - it iterates through element keys:
      expect (f (M.id, base.ielems, elements)).to_equal {"a", "b", "c", "d", "e"}
      expect (f (M.id, base.elems, inverse)).to_contain.a_permutation_of {1, 2, 3, 4, 5}
  - it passes all iteration result values to filter predicate:
      t = {}
      f (function (k, v) t[k] = v end, pairs, elements)
      expect (t).to_equal (elements)
  - it returns a list of filtered single return value iterator results:
      expect (f (function (e) return e:match "[aeiou]" end, base.ielems, elements)).
        to_equal {"a", "e"}
  - it returns a table of filtered key:value iterator results:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, pairs, t)).
        to_equal {"first", last="three"}
      expect (f (function (k, v) return k % 2 == 0 end, ipairs, elements)).
        to_equal {[2]="b", [4]="d"}
  - it defaults to pairs iteration:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, t)).
        to_equal {"first", last="three"}


- describe fold:
  - before:
      op = require "std.operator"
      f = M.fold

  - it writes a deprecation warning on first call:
      expect (capture (f, {M.id, 1, ipairs, {}})).
        to_contain_error "was deprecated"
      expect (capture (f, {M.id, 1, ipairs, {}})).
        not_to_contain_error "was deprecated"

  - it works with an empty table:
      expect (f (op["+"], 2, ipairs, {})).to_be (2)
  - it calls a binary function over single return value iterator results:
      expect (f (op["+"], 2, base.ielems, {3})).
        to_be (2 + 3)
      expect (f (op["*"], 2, base.ielems, {3, 4})).
        to_be (2 * 3 * 4)
  - it calls a binary function over key:value iterator results:
      expect (f (op["+"], 2, ipairs, {3})).to_be (2 + 3)
      expect (f (op["*"], 2, ipairs, {3, 4})).to_be (2 * 3 * 4)
  - it folds elements from left to right:
      expect (f (op["^"], 2, ipairs, {3, 4})).to_be ((2 ^ 3) ^ 4)


- describe foldl:
  - before:
      op = require "std.operator"
      f, badarg = init (M, this_module,  "foldl")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
      expect (f (f, nil)).to_raise (badarg (2, "any value or table"))
      expect (f (f, 42)).to_raise (badarg (3, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))
      expect (f (f, 42, false)).to_raise (badarg (3, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f (f, 42, {}, false)).to_raise (badarg (4))

  - it works with an empty table:
      expect (f (op["+"], 10000, {})).to_be (10000)
  - it folds a binary function through a table:
      expect (f (op["+"], 10000, {1, 10, 100})).to_be (10111)
  - it folds from left to right:
      expect (f (op["^"], 2, {3, 4})).to_be ((2 ^ 3) ^ 4)
  - it supports eliding init argument:
      expect (f (op["^"], {2, 3, 4})).to_be ((2 ^ 3) ^ 4)


- describe foldr:
  - before:
      op = require "std.operator"
      f, badarg = init (M, this_module,  "foldr")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
      expect (f (f, nil)).to_raise (badarg (2, "any value or table"))
      expect (f (f, 42)).to_raise (badarg (3, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))
      expect (f (f, 42, false)).to_raise (badarg (3, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f (f, 42, {}, false)).to_raise (badarg (4))

  - it works with an empty table:
      expect (f (op["+"], 1, {})).to_be (1)
  - it folds a binary function through a table:
      expect (f (op["+"], {10000, 100, 10, 1})).to_be (10111)
  - it folds from right to left:
      expect (f (op["/"], 10, {10000, 100})).to_be (10000 / (100 / 10))
  - it supports eliding init argument:
      expect (f (op["/"], {10000, 100, 10})).to_be (10000 / (100 / 10))


- describe id:
  - before:
      f = M.id
  - it returns argument unchanged:
      expect (f (true)).to_be (true)
      expect (f {1, 1, 2, 3}).to_equal {1, 1, 2, 3}
  - it returns multiple arguments unchanged:
      expect ({f (1, "two", false)}).to_equal {1, "two", false}


- describe lambda:
  - before:
      f, badarg = init (M, this_module,  "lambda")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "string"))
  - it diagnoses wrong arguments types:
      expect (f (false)).to_raise (badarg (1, "string", "boolean"))
  - it diagnoses too many arguments:
      expect (f ("foo", false)).to_raise (badarg (2))
  - it diagnoses bad lambda string:
      expect (select (2, f "foo")).to_be "invalid lambda string 'foo'"
  - it diagnoses an uncompilable expression:
      expect (select (2, f "||+")).to_be "invalid lambda string '||+'"
      expect (select (2, f "=")).to_be "invalid lambda string '='"

  - context with argument format:
    - it returns a function:
        expect (prototype (f "|x| 1+x")).to_be "function"
    - it compiles to a working Lua function:
        fn = f "||42"
        expect (fn ()).to_be (42)
    - it propagates argument values:
        fn = f "|...| {...}"
        expect (fn (1,2,3)).to_equal {1,2,3}
  - context with expression format:
    - it returns a function:
        expect (prototype (f "=1")).to_be "function"
    - it compiles to a working Lua function:
        fn = f "=42"
        expect (fn ()).to_be (42)
    - it sets auto-argument values:
        fn = f "=_1*_1"
        expect (fn (42)).to_be (1764)


- describe map:
  - before:
     elements = {"a", "b", "c", "d", "e"}
     inverse  = require "std.table".invert (elements)

     f, badarg = init (M, this_module,  "map")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
      expect (f (f)).to_raise (badarg (2, "function or any value"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))

  - it works with an empty table:
      expect (f (M.id, ipairs, {})).to_equal {}
  - it iterates through elements:
      expect (f (M.id, ipairs, elements)).to_equal (elements)
      expect (f (M.id, pairs, inverse)).to_contain.a_permutation_of (elements)
  - it passes all iteration result values to map function:
      t = {}
      f (function (k, v) t[k] = v end, pairs, elements)
      expect (t).to_equal (elements)
  - it returns a list of mapped single return value iterator results:
      expect (f (function (e) return e:match "[aeiou]" end, base.ielems, elements)).
        to_equal {"a", "e"}
      expect (f (function (e) return e .. "x" end, base.elems, elements)).
        to_contain.a_permutation_of {"ax", "bx", "cx", "dx", "ex"}
  - it returns a table of mapped key:value iterator results:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, pairs, t)).
        to_contain.a_permutation_of {true, false, true}
      expect (f (function (k, v) return k % 2 == 0 end, ipairs, elements)).
        to_equal {false, true, false, true, false}
  - it supports key:value results from mapping function:
      expect (f (function (k, v) return v, k end, pairs, elements)).
        to_equal (inverse)
  - it defaults to pairs iteration:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, t)).
        to_contain.a_permutation_of {true, false, true}


- describe map_with:
  - before:
      t = {{1, 2, 3}, {4, 5}}
      fn = function (...) return select ("#", ...) end

      f, badarg = init (M, this_module,  "map_with")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
      expect (f (fn)).to_raise (badarg (2, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))
      expect (f (fn, false)).to_raise (badarg (2, "table", "boolean"))
      expect (f (fn, {{}, false})).
        to_raise (badarg (2, "table of tables", "boolean at index 2"))
  - it diagnoses too many arguments:
      expect (f (fn, t, false)).to_raise (badarg (3))

  - it works for an empty table:
      expect (f (fn, {})).to_equal ({})
  - it returns a table:
      u = f (fn, t)
      expect (type (u)).to_be "table"
  - it creates a new table:
      old = t
      u = f (fn, t)
      expect (t).to_equal (old)
      expect (u).not_to_equal (old)
      expect (t).to_equal {{1, 2, 3}, {4, 5}}
  - it maps a function over a list of argument lists:
      expect (f (fn, t)).to_equal {3, 2}
  - it discards hash-part arguments:
      expect (f (fn, {{1,x=2,3}, {4,5,y="z"}})).to_equal {2, 2}
  - it maps a function over a table of argument lists:
      expect (f (fn, {a={1,2,3}, b={4,5}})).to_equal {a=3, b=2}


- describe memoize:
  - before:
      f, badarg = init (M, this_module,  "memoize")

      memfn = f (function (x)
                   if x then return {x} else return nil, "bzzt" end
                 end)

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))
      expect (f (f, false)).to_raise (badarg (2, "function or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f (f, f, false)).to_raise (badarg (3))

  - it propagates multiple return values:
      expect (select (2, memfn (false))).to_be "bzzt"
  - it returns the same object for the same arguments:
      t = memfn (1)
      expect (memfn (1)).to_be (t)
  - it returns a different object for different arguments:
      expect (memfn (1)).not_to_be (memfn (2))
  - it returns the same object for table valued arguments:
      t = memfn {1, 2, 3}
      expect (memfn {1, 2, 3}).to_be (t)
      t = memfn {foo = "bar", baz = "quux"}
      expect (memfn {foo = "bar", baz = "quux"}).to_be (t)
      expect (memfn {baz = "quux", foo = "bar"}).to_be (t)
  - it returns a different object for different table arguments:
      expect (memfn {1, 2, 3}).not_to_be (memfn {1, 2})
      expect (memfn {1, 2, 3}).not_to_be (memfn {3, 1, 2})
      expect (memfn {1, 2, 3}).not_to_be (memfn {1, 2, 3, 4})
  - it accepts alternative normalization function:
      normalize = function (...) return select ("#", ...) end
      memfn = f (function (x) return {x} end, normalize)
      expect (memfn "same").to_be (memfn "not same")
      expect (memfn (1, 2)).to_be (memfn (false, "x"))
      expect (memfn "one").not_to_be (memfn ("one", "two"))


- describe nop:
  - before:
      f = M.nop
  - it accepts any number of arguments:
      expect (f ()).to_be (nil)
      expect (f (false)).to_be (nil)
      expect (f (1, 2, 3, nil, "str", {}, f)).to_be (nil)
  - it returns no values:
      expect (f (1, "two", false)).to_be (nil)


- describe op:
  - context with []:
    - before:
        f = M.op["[]"]

    - it writes a deprecation warning on first call:
        expect (capture (f, {{2}, 1})).
          to_contain_error "was deprecated"
        expect (capture (f, {{2}, 1})).
          not_to_contain_error "was deprecated"

    - it dereferences a table:
        expect (f ({}, 1)).to_be (nil)
        expect (f ({"foo", "bar"}, 1)).to_be "foo"
        expect (f ({foo = "bar"}, "foo")).to_be "bar"

  - context with +:
    - before:
        f = M.op["+"]

    - it writes a deprecation warning on first call:
        expect (capture (f, {2, 1})).
          to_contain_error "was deprecated"
        expect (capture (f, {2, 1})).
          not_to_contain_error "was deprecated"

    - it returns the sum of its arguments:
        expect (f (99, 2)).to_be (99 + 2)

  - context with -:
    - before:
        f = M.op["-"]

    - it writes a deprecation warning on first call:
        expect (capture (f, {2, 1})).
          to_contain_error "was deprecated"
        expect (capture (f, {2, 1})).
          not_to_contain_error "was deprecated"

    - it returns the difference of its arguments:
        expect (f (99, 2)).to_be (99 - 2)

  - context with *:
    - before:
        f = M.op["*"]

    - it writes a deprecation warning on first call:
        expect (capture (f, {2, 1})).
          to_contain_error "was deprecated"
        expect (capture (f, {2, 1})).
          not_to_contain_error "was deprecated"

    - it returns the product of its arguments:
        expect (f (99, 2)).to_be (99 * 2)

  - context with /:
    - before:
        f = M.op["/"]

    - it writes a deprecation warning on first call:
        expect (capture (f, {2, 1})).
          to_contain_error "was deprecated"
        expect (capture (f, {2, 1})).
          not_to_contain_error "was deprecated"

    - it returns the quotient of its arguments:
        expect (f (99, 2)).to_be (99 / 2)

  - context with and:
    - before:
        f = M.op["and"]

    - it writes a deprecation warning on first call:
        expect (capture (f, {true, false})).
          to_contain_error "was deprecated"
        expect (capture (f, {true, false})).
          not_to_contain_error "was deprecated"

    - it returns the logical and of its arguments:
        expect (f (false, false)).to_be (false)
        expect (f (false, true)).to_be (false)
        expect (f (true, false)).to_be (false)
        expect (f (true, true)).to_be (true)
    - it supports truthy and falsey arguments:
        expect (f ()).to_be (nil)
        expect (f (0)).to_be (nil)
        expect (f (nil, 0)).to_be (nil)
        expect (f (0, "false")).to_be ("false")

  - context with or:
    - before:
        f = M.op["or"]

    - it writes a deprecation warning on first call:
        expect (capture (f, {true, false})).
          to_contain_error "was deprecated"
        expect (capture (f, {true, false})).
          not_to_contain_error "was deprecated"

    - it returns the logical or of its arguments:
        expect (f (false, false)).to_be (false)
        expect (f (false, true)).to_be (true)
        expect (f (true, false)).to_be (true)
        expect (f (true, true)).to_be (true)
    - it supports truthy and falsey arguments:
        expect (f ()).to_be (nil)
        expect (f (0)).to_be (0)
        expect (f (nil, 0)).to_be (0)
        expect (f (0, "false")).to_be (0)

  - context with not:
    - before:
        f = M.op["not"]

    - it writes a deprecation warning on first call:
        expect (capture (f, {true})).
          to_contain_error "was deprecated"
        expect (capture (f, {true})).
          not_to_contain_error "was deprecated"

    - it returns the logical not of its argument:
        expect (f (false)).to_be (true)
        expect (f (true)).to_be (false)
    - it supports truthy and falsey arguments:
        expect (f ()).to_be (true)
        expect (f (0)).to_be (false)

  - context with ==:
    - before:
        f = M.op["=="]

    - it writes a deprecation warning on first call:
        expect (capture (f, {2, 1})).
          to_contain_error "was deprecated"
        expect (capture (f, {2, 1})).
          not_to_contain_error "was deprecated"

    - it returns true if the arguments are equal:
        expect (f ()).to_be (true)
        expect (f ("foo", "foo")).to_be (true)
    - it returns false if the arguments are unequal:
        expect (f (1)).to_be (false)
        expect (f ("foo", "bar")).to_be (false)

  - context with ~=:
    - before:
        f = M.op["~="]

    - it writes a deprecation warning on first call:
        expect (capture (f, {2, 1})).
          to_contain_error "was deprecated"
        expect (capture (f, {2, 1})).
          not_to_contain_error "was deprecated"

    - it returns false if the arguments are equal:
        expect (f (1, 1)).to_be (false)
        expect (f ("foo", "foo")).to_be (false)
    - it returns true if the arguments are unequal:
        expect (f (1, 2)).to_be (true)
        expect (f ("foo", "bar")).to_be (true)
        expect (f ({}, {})).to_be (true)


- describe reduce:
  - before:
      op = require "std.operator"
      f, badarg = init (M, this_module,  "reduce")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
      expect (f (f)).to_raise (badarg (2, "any value"))
      expect (f (f, 1)).to_raise (badarg (3, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))
      expect (f (f, 1, false)).to_raise (badarg (3, "function", "boolean"))

  - it works with an empty table:
      expect (f (op["+"], 2, ipairs, {})).to_be (2)
  - it calls a binary function over single return value iterator results:
      expect (f (op["+"], 2, base.ielems, {3})).
        to_be (2 + 3)
      expect (f (op["*"], 2, base.ielems, {3, 4})).
        to_be (2 * 3 * 4)
  - it calls a binary function over key:value iterator results:
      expect (f (op["+"], 2, ipairs, {3})).to_be (2 + 3)
      expect (f (op["*"], 2, ipairs, {3, 4})).to_be (2 * 3 * 4)
  - it reduces elements from left to right:
      expect (f (op["^"], 2, ipairs, {3, 4})).to_be ((2 ^ 3) ^ 4)


- describe zip:
  - before:
      tt = {{1, 2}, {3, 4}, {5, 6}}

      f, badarg = init (M, this_module,  "zip")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f (tt, false)).to_raise (badarg (2))

  - it works for an empty table:
      expect (f {}).to_equal {}
  - it is the inverse of itself:
      expect (f (f (tt))).to_equal (tt)
  - it transposes rows and columns:
      expect (f (tt)).to_equal {{1, 3, 5}, {2, 4, 6}}
      expect (f {x={a=1, b=2}, y={a=3, b=4}, z={b=5}}).
        to_equal {a={x=1, y=3}, b={x=2,y=4,z=5}}


- describe zip_with:
  - before:
      tt = {{1, 2}, {3, 4}, {5}}
      fn = function (...) return tonumber (table.concat {...}) end

      f, badarg = init (M, this_module,  "zip_with")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "function"))
      expect (f (fn)).to_raise (badarg (2, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "function", "boolean"))
      expect (f (fn, false)).to_raise (badarg (2, "table", "boolean"))
      expect (f (fn, {{}, false})).
        to_raise (badarg (2, "table of tables", "boolean at index 2"))
  - it diagnoses too many arguments:
      expect (f (fn, tt, false)).to_raise (badarg (3))

  - it works for an empty table:
      expect (f (fn, {})).to_equal {}
  - it returns a table:
      expect (type (f (fn, tt))).to_be "table"
  - it returns the result in a new table:
      expect (f (fn, tt)).not_to_be (tt)
  - it does not perturb the argument list:
      m = f (fn, tt)
      expect (tt).to_equal {{1, 2}, {3, 4}, {5}}
  - it combines column entries with a function:
      expect (f (fn, tt)).to_equal {135, 24}
  - it discards hash-part arguments:
      expect (f (fn, {{1,2}, x={3,4}, {[2]=5}})).to_equal {1, 25}
  - it combines matching key entries with a function:
      expect (f (fn, {{a=1,b=2}, {a=3,b=4}, {b=5}})).
        to_equal {a=13, b=245}
