before: |
  this_module  = "std.functional"
  global_table = "_G"

  M = require (this_module)

specify std.functional:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}


- describe bind:
  - it diagnoses missing arguments: |
      expect (M.bind ()).
        to_error "bad argument #1 to 'std.functional.bind' (function expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.bind (false)).
        to_error "bad argument #1 to 'std.functional.bind' (function expected, got boolean)"
  - it does not affect normal operation if no arguments are bound:
      expect (M.bind (math.min, {}) (2, 3, 4)).
        to_equal (2)
  - it takes the extra arguments into account:
      expect (M.bind (math.min, {1, 0}) (2, 3, 4)).
        to_equal (0)
  - it supports out of order extra arguments:
      expect (M.bind (math.pow, {[2] = 3}) (2)).
        to_equal (8)


- describe case:
  - before:
      yes     = function ()  return true end
      no      = function ()  return false end
      default = function (s) return s end
      branches = { yes = yes, no = no, default }
  - it diagnoses missing arguments: |
      expect (M.case (nil)).
        to_error "bad argument #2 to 'std.functional.case' (non-empty table expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.case ("no", false)).
        to_error "bad argument #2 to 'std.functional.case' (non-empty table expected, got boolean)"
  - it matches against branch keys:
      expect (M.case ("yes", branches)).to_be (true)
      expect (M.case ("no",  branches)).to_be (false)
  - it has a default for unmatched keys:
      expect (M.case ("none", branches)).to_be "none"
  - it returns nil for unmatched keys with no default:
      expect (M.case ("none", { yes = yes, no = no })).to_be (nil)
  - it evaluates `with` exactly once:
      s = "prince"
      function acc () s = s .. "s"; return s end
      expect (M.case (acc (), {
        prince   = function () return "one" end,
        princes  = function () return "many" end,
        princess = function () return "one" end,
                   function () return "gibberish" end,
      })).to_be "many"


- describe collect:
  - it diagnoses missing arguments: |
      expect (M.collect ()).
        to_error "bad argument #1 to 'std.functional.collect' (function expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.collect (false)).
        to_error "bad argument #1 to 'std.functional.collect' (function expected, got boolean)"


- describe compose:
  - it diagnoses missing arguments: |
      expect (M.compose ()).
        to_error "bad argument #1 to 'std.functional.compose' (function expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.compose (false)).
        to_error "bad argument #1 to 'std.functional.compose' (function expected, got boolean)"
      expect (M.compose (M.id, false)).
        to_error "bad argument #2 to 'std.functional.compose' (function expected, got boolean)"
  - it composes functions in the correct order:
      expect (M.compose (math.sin, math.cos) (1)).
        to_equal (math.cos (math.sin (1)))


- describe curry:
  - it diagnoses missing arguments: |
      expect (M.curry ()).
        to_error "bad argument #1 to 'std.functional.curry' (function expected, got no value)"
      expect (M.curry (M.id)).
        to_error "bad argument #2 to 'std.functional.curry' (number expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.curry (false)).
        to_error "bad argument #1 to 'std.functional.curry' (function expected, got boolean)"
      expect (M.curry (M.id, false)).
        to_error "bad argument #2 to 'std.functional.curry' (number expected, got boolean)"


- describe eval:
  - it diagnoses missing arguments: |
      expect (M.eval ()).
        to_error "bad argument #1 to 'std.functional.eval' (string expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.eval (false)).
        to_error "bad argument #1 to 'std.functional.eval' (string expected, got boolean)"


- describe filter:
  - it diagnoses missing arguments: |
      expect (M.filter ()).
        to_error "bad argument #1 to 'std.functional.filter' (function expected, got no value)"
      expect (M.filter (M.id)).
        to_error "bad argument #2 to 'std.functional.filter' (function expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.filter (false)).
        to_error "bad argument #1 to 'std.functional.filter' (function expected, got boolean)"
      expect (M.filter (M.id, false)).
        to_error "bad argument #2 to 'std.functional.filter' (function expected, got boolean)"


- describe fold:
  - it diagnoses missing arguments: |
      expect (M.fold ()).
        to_error "bad argument #1 to 'std.functional.fold' (function expected, got no value)"
      expect (M.fold (M.id)).
        to_error "bad argument #2 to 'std.functional.fold' (any value expected, got no value)"
      expect (M.fold (M.id, 1)).
        to_error "bad argument #3 to 'std.functional.fold' (function expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.fold (false)).
        to_error "bad argument #1 to 'std.functional.fold' (function expected, got boolean)"
      expect (M.fold (M.id, 1, false)).
        to_error "bad argument #3 to 'std.functional.fold' (function expected, got boolean)"


- describe id:


- describe map:
  - it diagnoses missing arguments: |
      expect (M.map ()).
        to_error "bad argument #1 to 'std.functional.map' (function expected, got no value)"
      expect (M.map (M.id)).
        to_error "bad argument #2 to 'std.functional.map' (function expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.map (false)).
        to_error "bad argument #1 to 'std.functional.map' (function expected, got boolean)"
      expect (M.map (M.id, false)).
        to_error "bad argument #2 to 'std.functional.map' (function expected, got boolean)"


- describe memoize:
  - it diagnoses missing arguments: |
      expect (M.memoize ()).
        to_error "bad argument #1 to 'std.functional.memoize' (function expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.memoize (false)).
        to_error "bad argument #1 to 'std.functional.memoize' (function expected, got boolean)"
      expect (M.memoize (M.id, false)).
        to_error "bad argument #2 to 'std.functional.memoize' (function or nil expected, got boolean)"
