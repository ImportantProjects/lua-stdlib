before:
  base = require "std.base"

  this_module  = "std.functional"
  global_table = "_G"

  exported_apis = { 1, "bind", "case", "collect", "compose", "curry", "eval",
                    "filter", "fold", "id", "map", "memoize", "nop", "op",
                    "reduce" }

  M = require (this_module)

specify std.functional:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}
  - it exports the documented apis:
      t = {}
      for k in pairs (M) do t[#t + 1] = k end
      expect (t).to_contain.a_permutation_of (exported_apis)

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}


- describe bind:
  - before:
      fname = "bind"
      f = M[fname]

  # Long-hand badarg calls until we know bind meets specifications!
  - it diagnoses missing arguments:
      expect (f ()).to_error (badarg (this_module, fname, 1, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).
        to_error (badarg (this_module, fname, 1, "function", "boolean"))

  - it writes a deprecation warning to standard error on first call: |
      -- Unwrap functable
      f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

      _, err = capture (f, {badarg, this_module, fname})
      if err ~= nil then
        -- skip this test when using Specl < 12 capture stub
        expect (err).to_contain "multi-argument 'std.functional.bind' was deprecated"
      end
      _, err = capture (f, {badarg, this_module, fname})
      expect (err).to_be (nil)

  - it does not affect normal operation if no arguments are bound:
      expect (f (math.min, {}) (2, 3, 4)).to_be (2)
  - it takes the extra arguments into account:
      expect (f (math.min, {1, 0}) (2, 3, 4)).to_be (0)
  - it appends final call arguments:
      expect (f (math.max, {2, 3}) (4, 5, 1)).to_be (5)
  - it does not require all arguments in final call:
      div = function (a, b) return a / b end
      expect (f (div, {100}) (25)).to_be (4)
  - it supports out of order extra arguments:
      expect (f (math.pow, {[2] = 3}) (2)).to_be (8)
  - it supports the legacy api:
      expect (f (math.min) (2, 3, 4)).to_be (2)
      expect (f (math.min, 1, 0) (2, 3, 4)).to_be (0)
      expect (f (math.pow, nil, 3) (2)).to_be (8)


- describe case:
  - before:
      yes     = function ()  return true end
      no      = function ()  return false end
      default = function (s) return s end
      branches = { yes = yes, no = no, default }

      fname = "case"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (2, "non-empty table"))
  - it diagnoses wrong argument types:
      expect (f ("no", false)).
        to_error (msg (2, "non-empty table", "boolean"))
  - it diagnoses too many arguments:
      expect (f (1, {2}, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - it matches against branch keys:
      expect (f ("yes", branches)).to_be (true)
      expect (f ("no",  branches)).to_be (false)
  - it has a default for unmatched keys:
      expect (f ("none", branches)).to_be "none"
  - it returns nil for unmatched keys with no default:
      expect (f ("none", { yes = yes, no = no })).to_be (nil)
  - it returns non-function matches:
      expect (f ("t", {t = true})).to_be (true)
  - it evaluates returned functions:
      expect (f ("fn", {fn = function () return true end})).
        to_be (true)
  - it passes 'with' to function matches:
      expect (f ("with", {function (s) return s end})).to_be "with"
  - it evaluates returned functables:
      functable = setmetatable ({}, {__call = function (t, with) return with end})
      expect (f ("functable", {functable})).to_be "functable"
  - it evaluates 'with` exactly once:
      s = "prince"
      function acc () s = s .. "s"; return s end
      expect (f (acc (), {
        prince   = function () return "one" end,
        princes  = function () return "many" end,
        princess = function () return "one" end,
                   function () return "gibberish" end,
      })).to_be "many"


- describe collect:
  - before:
      fname = "collect"
      msg = M.bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "function", "boolean"))

  - it collects a list of single return value iterator results:
      expect (f (base.ielems, {"a", "b", "c"})).to_equal {"a", "b", "c"}
  - it collects a table of key:value iterator results:
      t = {"first", second="two", last=3}
      expect (f (pairs, t)).to_equal (t)


- describe compose:
  - before:
      fname = "compose"
      msg = M.bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (f (f, false)).to_error (msg (2, "function", "boolean"))

  - it composes a single function correctly:
      expect (f (M.id) (1)).to_be (1)
  - it composes functions in the correct order:
      expect (f (math.sin, math.cos) (1)).
        to_be (math.cos (math.sin (1)))


- describe curry:
  - before:
      fname = "curry"
      msg = M.bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
      expect (f (f)).to_error (msg (2, "int"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (f (f, 1.234)).to_error (msg (2, "int", "number"))
  - it diagnoses too many arguments:
      expect (f (f, 2, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - it returns a zero argument function uncurried:
      expect (f (f, 0)).to_be (f)
  - it returns a one argument function uncurried:
      expect (f (f, 1)).to_be (f)
  - it curries a two argument function:
      expect (f (f, 2)).not_to_be (f)
  - it evaluates intermediate arguments one at a time:
      expect (f (math.min, 3) (2) (3) (4)).to_equal (2)
  - it returns a curried function that can be partially applied:
      bin = f (math.pow, 2) (2)
      expect (bin (2)).to_be (math.pow (2, 2))
      expect (bin (10)).to_be (math.pow (2, 10))


- describe eval:
  - before:
      fname = "eval"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it writes a deprecation warning to standard error on first call: |
      _, err = capture (f, {"42"})
      if err ~= nil then
        -- skip this test when using Specl < 12 capture stub
        expect (err).to_contain "'std.functional.eval' was deprecated"
      end
      _, err = capture (f, {"42"})
      expect (err).to_be (nil)

  - it diagnoses invalid lua:
      # Some internal error when eval tries to call uncompilable "=" code.
      expect (f "=").to_error ()
  - it evaluates a string of lua code:
      expect (f "math.pow (2, 10)").to_be (math.pow (2, 10))


- describe filter:
  - before:
     elements = {"a", "b", "c", "d", "e"}
     inverse  = require "std.table".invert (elements)
     fname = "filter"
      msg = M.bind (badarg, {this_module, fname})
     f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
      expect (f (f)).to_error (msg (2, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (f (f, false)).to_error (msg (2, "function", "boolean"))

  - it works with an empty table:
      expect (f (M.id, pairs, {})).to_equal {}
  - it iterates through element keys:
      expect (f (M.id, base.ielems, elements)).to_equal {"a", "b", "c", "d", "e"}
      expect (f (M.id, base.elems, inverse)).to_contain.a_permutation_of {1, 2, 3, 4, 5}
  - it passes all iteration result values to filter predicate:
      t = {}
      f (function (k, v) t[k] = v end, pairs, elements)
      expect (t).to_equal (elements)
  - it returns a list of filtered single return value iterator results:
      expect (f (function (e) return e:match "[aeiou]" end, base.ielems, elements)).
        to_equal {"a", "e"}
  - it returns a table of filtered key:value iterator results:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, pairs, t)).
        to_equal {"first", last="three"}
      expect (f (function (k, v) return k % 2 == 0 end, ipairs, elements)).
        to_equal {[2]="b", [4]="d"}


- describe fold:
  - before:
      fname = "fold"
      f = M[fname]

  - it writes a deprecation warning to standard error on first call: |
      _, err = capture (f, {M.id, 1, ipairs, {}})
      if err ~= nil then
        -- skip this test when using Specl < 12 capture stub
        expect (err).to_contain "'std.functional.fold' was deprecated"
      end
      _, err = capture (f, {M.id, 1, ipairs, {}})
      expect (err).to_be (nil)

  - it works with an empty table:
      expect (f (M.op["+"], 2, ipairs, {})).to_be (2)
  - it calls a binary function over single return value iterator results:
      expect (f (M.op["+"], 2, base.ielems, {3})).
        to_be (2 + 3)
      expect (f (M.op["*"], 2, base.ielems, {3, 4})).
        to_be (2 * 3 * 4)
  - it calls a binary function over key:value iterator results:
      expect (f (M.op["+"], 2, ipairs, {3})).to_be (2 + 3)
      expect (f (M.op["*"], 2, ipairs, {3, 4})).to_be (2 * 3 * 4)
  - it folds elements from left to right:
      expect (f (M.op["^"], 2, ipairs, {3, 4})).to_be ((2 ^ 3) ^ 4)


- describe id:
  - before:
      f = M.id
  - it returns argument unchanged:
      expect (f (true)).to_be (true)
      expect (f {1, 1, 2, 3}).to_equal {1, 1, 2, 3}
  - it returns multiple arguments unchanged:
      expect ({f (1, "two", false)}).to_equal {1, "two", false}


- describe map:
  - before:
     elements = {"a", "b", "c", "d", "e"}
     inverse  = require "std.table".invert (elements)
     fname = "map"
     msg = M.bind (badarg, {this_module, fname})
     f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
      expect (f (f)).to_error (msg (2, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (f (f, false)).to_error (msg (2, "function", "boolean"))

  - it works with an empty table:
      expect (f (M.id, ipairs, {})).to_equal {}
  - it iterates through elements:
      expect (f (M.id, ipairs, elements)).to_equal (elements)
      expect (f (M.id, pairs, inverse)).to_contain.a_permutation_of (elements)
  - it passes all iteration result values to map function:
      t = {}
      f (function (k, v) t[k] = v end, pairs, elements)
      expect (t).to_equal (elements)
  - it returns a list of mapped single return value iterator results:
      expect (f (function (e) return e:match "[aeiou]" end, base.ielems, elements)).
        to_equal {"a", "e"}
      expect (f (function (e) return e .. "x" end, base.elems, elements)).
        to_contain.a_permutation_of {"ax", "bx", "cx", "dx", "ex"}
  - it returns a table of mapped key:value iterator results:
      t = {"first", second=2, last="three"}
      expect (f (function (k, v) return type (v) == "string" end, pairs, t)).
        to_contain.a_permutation_of {true, false, true}
      expect (f (function (k, v) return k % 2 == 0 end, ipairs, elements)).
        to_equal {false, true, false, true, false}
  - it supports key:value results from mapping function:
      expect (f (function (k, v) return v, k end, pairs, elements)).
        to_equal (inverse)


- describe memoize:
  - before:
      fname = "memoize"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

      memfn = f (function (x)
                   if x then return {x} else return nil, "bzzt" end
                 end)

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (f (f, false)).to_error (msg (2, "function or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f (f, f, false)).to_error (toomanyarg (this_module, fname, 2, 3))

  - it propagates multiple return values:
      expect (select (2, memfn (false))).to_be "bzzt"
  - it returns the same object for the same arguments:
      t = memfn (1)
      expect (memfn (1)).to_be (t)
  - it returns a different object for different arguments:
      expect (memfn (1)).not_to_be (memfn (2))
  - it returns the same object for table valued arguments:
      t = memfn {1, 2, 3}
      expect (memfn {1, 2, 3}).to_be (t)
      t = memfn {foo = "bar", baz = "quux"}
      expect (memfn {foo = "bar", baz = "quux"}).to_be (t)
      expect (memfn {baz = "quux", foo = "bar"}).to_be (t)
  - it returns a different object for different table arguments:
      expect (memfn {1, 2, 3}).not_to_be (memfn {1, 2})
      expect (memfn {1, 2, 3}).not_to_be (memfn {3, 1, 2})
      expect (memfn {1, 2, 3}).not_to_be (memfn {1, 2, 3, 4})
  - it accepts alternative normalization function:
      normalize = function (...) return select ("#", ...) end
      memfn = f (function (x) return {x} end, normalize)
      expect (memfn "same").to_be (memfn "not same")
      expect (memfn (1, 2)).to_be (memfn (false, "x"))
      expect (memfn "one").not_to_be (memfn ("one", "two"))


- describe nop:
  - before:
      f = M.nop
  - it accepts any number of arguments:
      expect (f ()).to_be (nil)
      expect (f (false)).to_be (nil)
      expect (f (1, 2, 3, nil, "str", {}, f)).to_be (nil)
  - it returns no values:
      expect (f (1, "two", false)).to_be (nil)


- describe reduce:
  - before:
      fname = "reduce"
      msg = M.bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
      expect (f (f)).to_error (msg (2, "any value"))
      expect (f (f, 1)).to_error (msg (3, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (f (f, 1, false)).to_error (msg (3, "function", "boolean"))

  - it works with an empty table:
      expect (f (M.op["+"], 2, ipairs, {})).to_be (2)
  - it calls a binary function over single return value iterator results:
      expect (f (M.op["+"], 2, base.ielems, {3})).
        to_be (2 + 3)
      expect (f (M.op["*"], 2, base.ielems, {3, 4})).
        to_be (2 * 3 * 4)
  - it calls a binary function over key:value iterator results:
      expect (f (M.op["+"], 2, ipairs, {3})).to_be (2 + 3)
      expect (f (M.op["*"], 2, ipairs, {3, 4})).to_be (2 * 3 * 4)
  - it reduces elements from left to right:
      expect (f (M.op["^"], 2, ipairs, {3, 4})).to_be ((2 ^ 3) ^ 4)
