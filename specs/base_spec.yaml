before:
  this_module = "std.base"

  M = require (this_module)

  nop = M.nop

specify std.base:
- describe deprecate:
  - before: |
      function runscript (body, name, args)
        return luaproc (
          "require 'std.base'.deprecate (function (...)" ..
          " " .. body ..
          " end, '" .. (name or "runscript") .. "') " ..
          "('" .. table.concat (args or {}, "', '") .. "')"
        )
      end

      fname = "deprecate"
      -- Don't depend on functional.bind for base specs!
      msg = function (...) return badarg (this_module, fname, ...) end
      f = M[fname]

  - it diagnoses missing arguments: |
      expect (f ()).to_error (msg (1, "function"))
      expect (f (function () end)).
        to_error "missing argument to 'std.base.deprecate' (2 or 3 arguments expected)"

  - it returns a function:
      f = M.deprecate (function () end, "clone_rename")
      expect (type (f)).to_be "function"
  - context with deprecated function:
    - it executes the deprecated function:
        expect (runscript 'error "oh noes!"').to_contain_error "oh noes!"
    - it passes arguments to the deprecated function:
        expect (runscript ("print (table.concat ({...}, ', '))", nil,
                           {"foo", "bar", "baz"})).to_output "foo, bar, baz\n"
    - it returns deprecated function results:
        script = [[
          deprecate = require "std.base".deprecate
          fn = deprecate (function () return "foo", "bar", "baz" end, "fn")
          print (fn ())
        ]]
        expect (luaproc (script)).to_output "foo\tbar\tbaz\n"
    - it writes a warning to stderr:
        expect (runscript 'error "oh noes!"').
          to_contain_error "deprecated, and will go away"
    - it writes the call location to stderr: |
        expect (runscript 'error "oh noes!"').
          to_match_error "^%S+:1: "
    - it does not repeat the warning on additional calls:
        script = [[
          deprecate = require "std.base".deprecate
          fn = deprecate (function () error "oh noes!" end, "fn")
          fn ()  -- line 3
          fn ()  -- line 4
        ]]
        expect (luaproc (script)).
          not_to_match_error "^%S+:3:.*deprecated.*\n%S+:4:.*deprecated"

- describe export:
  - before:
      function mkstack (level, types)
        return string.format ([[
          _DEBUG = %s                                    -- line 1
          local export = require "std.base".export       -- line 2
          export ("ohnoes", 1, "table", t, %s) -- line 4
          end                                            -- line 5
          function caller ()                             -- line 6
            local r = ohnoes "not a table"               -- line 7
            return "not a tail call"                     -- line 8
          end                                            -- line 9
          caller ()                                      -- line 10
        ]], tostring (debugp), tostring (level))
      end

      MAGIC = { "unique!" }
      mkmagic = function () return MAGIC end

      fname = "export"
      msg = function (...) return badarg (this_module, fname, ...) end
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
      expect (f ({})).to_error (msg (2, "string"))
      expect (f ({}, "")).to_error (msg (3, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
      expect (f ({}, false)).to_error (msg (2, "string", "boolean"))
      expect (f ({}, "", false)).to_error (msg (3, "function", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, "", function () end, false)).
        to_error (toomanyarg (this_module, fname, 3, 4))
  - it diagnoses missing module name element:
      expect (f ({}, "", function () end)).
        to_error (msg (1, "module name at index 1"))
  - it diagnoses malformed declaration string: |
      M = { "base_spec.yaml" }
      expect (f (M, "", function () end)).to_error "function name expected"
      expect (f (M, "woo", function () end)).
        to_error "argument type specifications expected"
      expect (f (M, "woo ()", function () end)).
        to_error (msg (2, "at least 1 argument type", "0"))

  - it returns the supplied function:
      M = { "base_spec.yaml" }
      expect (f (M, "expect (any)", f)).to_be (f)
  - it stores a function in supplied table at the specified key:
      M = { "base_spec.yaml" }
      f (M, "export (any?)", mkmagic)
      expect (M.export ()).to_be (MAGIC)
  - it stores the passed function when _ARGCHECK is disabled:
      script = [[
        _DEBUG = false
        local debug = require "std.debug_init"
        local export = require "std.base".export
        M = { "base_spec.yaml" }
        export (M, "export (any)", export)
        os.exit (M.export == export and 0 or 1)
      ]]
      expect (luaproc (script)).to_succeed ()
  - context when checking single argument function:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module }
        fname = "chk_function"
        msg = function (...) return badarg (fake_module, fname, ...) end
        f (M, "chk_function (#table)", mkmagic)
        chk = M[fname]
    - it diagnoses missing arguments:
        expect (chk ()).to_error (msg (1, "non-empty table"))
    - it diagnoses wrong argument types:
        expect (chk {}).to_error (msg (1, "non-empty table", "empty table"))
    - it diagnoses too many arguments:
        expect (chk ({1}, 2, nop, "", false)).
          to_error (toomanyarg (fake_module, fname, 1, 5))
    - it accepts correct argument types:
        expect (chk ({1})).to_equal (MAGIC) -- should be .to_be?
  - context when checking multi-argument function:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module }
        fname = "chk_function"
        msg = function (...) return badarg (fake_module, fname, ...) end
        f (M, "chk_function (table, function)", mkmagic)
        chk = M[fname]
    - it diagnoses missing arguments:
        expect (chk ()).to_error (msg (1, "table"))
        expect (chk ({})).to_error (msg (2, "function"))
    - it diagnoses wrong argument types:
        expect (chk (false)).to_error (msg (1, "table", "boolean"))
        expect (chk ({}, false)).to_error (msg (2, "function", "boolean"))
    - it diagnoses too many arguments:
        expect (chk ({}, nop, false)).
          to_error (toomanyarg (fake_module, fname, 2, 3))
    - it accepts correct argument types:
        expect (chk ({}, nop)).to_equal (MAGIC) -- should be .to_be?
  - context when checking optional argument function:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module }
        fname = "chk_function"
        msg = function (...) return badarg (fake_module, fname, ...) end
        f (M, "chk_function ([int])", mkmagic)
        chk = M[fname]
    - it diagnoses wrong argument types:
        expect (chk (false)).to_error (msg (1, "int or nil", "boolean"))
    - it diagnoses too many arguments:
        expect (chk (1, nop)).
          to_error (toomanyarg (fake_module, fname, 1, 2))
    - it accepts correct argument types:
        expect (chk ()).to_equal (MAGIC) -- should be .to_be?
        expect (chk (1)).to_equal (MAGIC) -- should be .to_be?
  - context when checking optional multi-argument function:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module }
        fname = "chk_function"
        msg = function (...) return badarg (fake_module, fname, ...) end
        f (M, "chk_function ([int], string)", mkmagic)
        chk = M[fname]
    - it diagnoses missing arguments:
        expect (chk ()).to_error (msg (1, "int or string"))
        expect (chk (1)).to_error (msg (2, "string"))
    - it diagnoses wrong argument types:
        expect (chk (false)).to_error (msg (1, "int or string", "boolean"))
    - it diagnoses too many arguments:
        expect (chk (1, "two", nop)).
          to_error (toomanyarg (fake_module, fname, 2, 3))
    - it accepts correct argument types:
        expect (chk ("two")).to_equal (MAGIC) -- should be .to_be?
        expect (chk (1, "two")).to_equal (MAGIC) -- should be .to_be?
  - context when checking self on an object method:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module, "Object" }
        fname = "chk_method"
        msg = function (...)
                return badarg (nil, fake_module .. ":" .. fname, ...)
              end
        f (M, "chk_method (string)", function (self, x) return x end)
        Object = require "std.object" {}
        Bad = Object { _type = "Bad" }
        obj = Object { chk = M.chk_method }
    - it diagnoses missing arguments:
        expect (obj.chk ()).to_error (msg (0, "Object"))
        expect (obj:chk ()).to_error (msg (1, "string"))
    - it diagnoses wrong argument types:
        expect (obj.chk ({})).to_error (msg (0, "Object", "empty table"))
        expect (obj.chk (Bad)).to_error (msg (0, "Object", "Bad"))
        expect (obj:chk ({})).to_error (msg (1, "string", "empty table"))
        expect (obj:chk (obj)).to_error (msg (1, "string", "Object"))
    - it diagnoses too many arguments:
        expect (obj.chk (obj, "str", false)).
          to_error (toomanyarg (nil, fake_module .. ":" .. fname, 1, 2))
        expect (obj:chk ("str", false)).
          to_error (toomanyarg (nil, fake_module .. ":" .. fname, 1, 2))
    - it accepts correct argument types:
        expect (obj.chk (obj, "str")).to_be "str"
        expect (obj.chk (Object, "str")).to_be "str"
        expect (obj:chk ("str")).to_be "str"
