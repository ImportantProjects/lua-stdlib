before:
  this_module = "std.base"

  M = require (this_module)

  nop = function () end

specify std.base:
- describe DEPRECATED:
  - before: |
      function runscript (body, name, args)
        return luaproc (
          "require 'std.base'.DEPRECATED ('0', '" .. (name or "runscript") .. "', function (...)" ..
          " " .. body ..
          " end) " ..
          "('" .. table.concat (args or {}, "', '") .. "')"
        )
      end

      f, badarg = init (M, "DEPRECATED")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "string"))
      expect (f "version").to_raise (badarg (2, "string"))
      expect (f ("version", "name")).to_raise (badarg (3, "string or function"))
      expect (f ("version", "name", "extramsg")).to_raise (badarg (4, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "string", "boolean"))
      expect (f ("version", false)).to_raise (badarg (2, "string", "boolean"))
      expect (f ("version", "name", false)).
        to_raise (badarg (3, "string or function", "boolean"))
      expect (f ("version", "name", "extramsg", false)).
        to_raise (badarg (4, "function", "boolean"))
  - it diagnoses too many arguments: |
      expect (f ("version", "name", "extramsg", nop, false)).
        to_raise (badarg (5))
      pending "issue #76"
      expect (f ("version", "name", nop, false)).to_raise (badarg (4))

  - it returns a function:
      expect (type (f ("0", "deprecated", nop))).to_be "function"
      expect (f ("0", "deprecated", nop)).not_to_be (nop)
  - context with deprecated function:
    - it executes the deprecated function:
        expect (runscript 'error "oh noes!"').to_contain_error "oh noes!"
    - it passes arguments to the deprecated function:
        expect (runscript ("print (table.concat ({...}, ', '))", nil,
                           {"foo", "bar", "baz"})).to_output "foo, bar, baz\n"
    - it returns deprecated function results: |
        script = [[
          DEPRECATED = require "std.base".DEPRECATED
          fn = DEPRECATED ("0", "fn", function () return "foo", "bar", "baz" end)
          print (fn ())
        ]]
        expect (luaproc (script)).to_output "foo\tbar\tbaz\n"
    - it writes a warning to stderr:
        expect (runscript 'error "oh noes!"').
          to_match_error "deprecated.*, and will be removed"
    - it writes the version string to stderr:
        expect (runscript 'error "oh noes!"').
          to_contain_error "in release 0"
    - it writes the call location to stderr: |
        expect (runscript 'error "oh noes!"').
          to_match_error "^%S+:1: "
    - context with _DEBUG:
      - before: |
          script = [[
            DEPRECATED = require "std.base".DEPRECATED
            fn = DEPRECATED ("0", "fn", function () io.stderr:write "oh noes!\n" end)
            fn ()  -- line 3
            fn ()  -- line 4
          ]]
      - it warns only on first call by default:
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).not_to_match_error "\n%S+:4:.*deprecated"
      - it warns only on first call with _DEBUG set to true:
          script = "_DEBUG = true " .. script
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).not_to_match_error "\n%S+:4:.*deprecated"
      - it warns only on first call with _DEBUG.compat unset:
          script = "_DEBUG = {} " .. script
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).not_to_match_error "\n%S+:4:.*deprecated"
      - it does not warn at all when set to false: |
          script = "_DEBUG = false " .. script
          expect (luaproc (script)).not_to_match_error "%d:.*deprecated"
      - it does not warn at all when compat field is set to true: |
          script = "_DEBUG = { compat = true } " .. script
          expect (luaproc (script)).not_to_match_error "%d:.*deprecated"
      - it warns on every call with compat field set to false:
          script = "_DEBUG = { compat = false } " .. script
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).to_match_error "\n%S+:4:.*deprecated"


- describe export:
  - before: |
      function mkstack (name, spec)
        return string.format ([[
          local export = require "std.base".export       -- line 1
          local function caller ()                       -- line 2
            export ({%s}, "%s", function () end)         -- line 3
          end                                            -- line 4
          caller ()                                      -- line 5
        ]], tostring (name), tostring (spec))
      end

      mkmagic = function () return "MAGIC" end

      f, badarg = init (M, "export")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
      expect (f ({})).to_raise (badarg (2, "string"))
      expect (f ({}, "")).to_raise (badarg (3, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
      expect (f ({}, false)).to_raise (badarg (2, "string", "boolean"))
      expect (f ({}, "", false)).to_raise (badarg (3, "function", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, "", function () end, false)).to_raise (badarg (4))
  - it diagnoses missing module name element at callsite: |
      expect (luaproc (mkstack ("", ""))).
        to_contain_error (":3: " .. badarg (1, "module name at index 1"))
  - it diagnoses malformed declaration string at callsite: |
      expect (luaproc (mkstack ('"mkstack"', ""))).
        to_contain_error (":3: " .. badarg (2, "function name"))
      expect (luaproc (mkstack ('"mkstack"', "woo"))).
        to_contain_error (":3: " .. badarg (2, "argument type specification"))

  - it returns the supplied function:
      M = { "base_spec.yaml" }
      expect (f (M, "expect (any)", f)).to_be (f)
  - it stores a function in supplied table at the specified key:
      M = { "base_spec.yaml" }
      f (M, "export (any?)", mkmagic)
      expect (M.export ()).to_be "MAGIC"
  - it stores the passed function when _ARGCHECK is disabled: |
      script = [[
        _DEBUG = false
        local debug = require "std.debug_init"
        local export = require "std.base".export
        M = { "base_spec.yaml" }
        export (M, "export (any)", export)
        os.exit (M.export == export and 0 or 1)
      ]]
      expect (luaproc (script)).to_succeed ()

  - context when checking zero argument function:
    - before:
        M = { "base_spec.yaml" }
        _, badarg = init (M, "chk_function")
        f (M, "chk_function ()", mkmagic)
        chk = M.chk_function
    - it diagnoses too many arguments:
        expect (chk (false)).to_raise (badarg (1))
    - it accepts correct argument types:
        expect (chk ()).to_be "MAGIC"

  - context when checking single argument function:
    - before:
        M = { "base_spec.yaml" }
        _, badarg = init (M, "chk_function")
        f (M, "chk_function (#table)", mkmagic)
        chk = M.chk_function
    - it diagnoses missing arguments:
        expect (chk ()).to_raise (badarg (1, "non-empty table"))
    - it diagnoses wrong argument types:
        expect (chk {}).to_raise (badarg (1, "non-empty table", "empty table"))
    - it diagnoses too many arguments:
        expect (chk ({1}, 2, nop, "", false)).to_raise (badarg (1, 5))
    - it accepts correct argument types:
        expect (chk ({1})).to_be "MAGIC"

  - context when checking multi-argument function:
    - before:
        M = { "base_spec.yaml" }
        _, badarg = init (M, "chk_function")
        f (M, "chk_function (table, function)", mkmagic)
        chk = M.chk_function
    - it diagnoses missing arguments:
        expect (chk ()).to_raise (badarg (1, "table"))
        expect (chk ({})).to_raise (badarg (2, "function"))
    - it diagnoses wrong argument types:
        expect (chk (false)).to_raise (badarg (1, "table", "boolean"))
        expect (chk ({}, false)).to_raise (badarg (2, "function", "boolean"))
    - it diagnoses too many arguments:
        expect (chk ({}, nop, false)).to_raise (badarg (3))
    - it accepts correct argument types:
        expect (chk ({}, nop)).to_be "MAGIC"

  - context when checking optional argument function:
    - before:
        M = { "base_spec.yaml" }
        _, badarg = init (M, "chk_function")
        f (M, "chk_function ([int])", mkmagic)
        chk = M.chk_function
    - it diagnoses wrong argument types:
        expect (chk (false)).to_raise (badarg (1, "int or nil", "boolean"))
    - it diagnoses too many arguments:
        expect (chk (1, nop)).to_raise (badarg (2))
    - it accepts correct argument types:
        expect (chk ()).to_be "MAGIC"
        expect (chk (1)).to_be "MAGIC"

  - context when checking optional multi-argument function:
    - before:
        M = { "base_spec.yaml" }
        _, badarg = init (M, "chk_function")
        f (M, "chk_function ([int], string)", mkmagic)
        chk = M.chk_function
    - it diagnoses missing arguments:
        expect (chk ()).to_raise (badarg (1, "int or string"))
        expect (chk (1)).to_raise (badarg (2, "string"))
    - it diagnoses wrong argument types:
        expect (chk (false)).to_raise (badarg (1, "int or string", "boolean"))
    - it diagnoses too many arguments:
        expect (chk (1, "two", nop)).to_raise (badarg (3))
    - it accepts correct argument types:
        expect (chk ("two")).to_be "MAGIC"
        expect (chk (1, "two")).to_be "MAGIC"

  - context when checking self on an object method:
    - before:
        M = { "base_spec.yaml", "Object" }
        _, badarg = init (M, "chk_method")
        f (M, "chk_method (string)", function (self, x) return x end)
        Object = require "std.object" {}
        Bad = Object { _type = "Bad" }
        obj = Object { chk = M.chk_method }
    - it diagnoses missing arguments:
        expect (obj.chk ()).to_raise (badarg (0, "Object"))
        expect (obj:chk ()).to_raise (badarg (1, "string"))
    - it diagnoses wrong argument types:
        expect (obj.chk ({})).to_raise (badarg (0, "Object", "empty table"))
        expect (obj.chk (Bad)).to_raise (badarg (0, "Object", "Bad"))
        expect (obj:chk ({})).to_raise (badarg (1, "string", "empty table"))
        expect (obj:chk (obj)).to_raise (badarg (1, "string", "Object"))
    - it diagnoses too many arguments:
        expect (obj.chk (obj, "str", false)).to_raise (badarg (2))
        expect (obj:chk ("str", false)).to_raise (badarg (2))
    - it accepts correct argument types:
        expect (obj.chk (obj, "str")).to_be "str"
        expect (obj.chk (Object, "str")).to_be "str"
        expect (obj:chk ("str")).to_be "str"
