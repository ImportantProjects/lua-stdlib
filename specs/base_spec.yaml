before:
  this_module = "std.base"

  M = require (this_module)

  nop = function () end

specify std.base:
- describe DEPRECATED:
  - before: |
      function runscript (body, name, args)
        return luaproc (
          "require 'std.base'.DEPRECATED ('0', '" .. (name or "runscript") .. "', function (...)" ..
          " " .. body ..
          " end) " ..
          "('" .. table.concat (args or {}, "', '") .. "')"
        )
      end

      f, badarg = init (M, this_module, "DEPRECATED")

  - it returns a function:
      expect (type (f ("0", "deprecated", nop))).to_be "function"
      expect (f ("0", "deprecated", nop)).not_to_be (nop)
  - context with deprecated function:
    - it executes the deprecated function:
        expect (runscript 'error "oh noes!"').to_contain_error "oh noes!"
    - it passes arguments to the deprecated function:
        expect (runscript ("print (table.concat ({...}, ', '))", nil,
                           {"foo", "bar", "baz"})).to_output "foo, bar, baz\n"
    - it returns deprecated function results: |
        script = [[
          DEPRECATED = require "std.base".DEPRECATED
          fn = DEPRECATED ("0", "fn", function () return "foo", "bar", "baz" end)
          print (fn ())
        ]]
        expect (luaproc (script)).to_output "foo\tbar\tbaz\n"
    - it writes a warning to stderr:
        expect (runscript 'error "oh noes!"').
          to_match_error "deprecated.*, and will be removed"
    - it writes the version string to stderr:
        expect (runscript 'error "oh noes!"').
          to_contain_error "in release 0"
    - it writes the call location to stderr: |
        expect (runscript 'error "oh noes!"').
          to_match_error "^%S+:1: "
    - context with _DEBUG:
      - before: |
          script = [[
            DEPRECATED = require "std.base".DEPRECATED
            fn = DEPRECATED ("0", "fn", function () io.stderr:write "oh noes!\n" end)
            fn ()  -- line 3
            fn ()  -- line 4
          ]]
      - it warns only on first call by default:
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).not_to_match_error "\n%S+:4:.*deprecated"
      - it warns only on first call with _DEBUG set to true:
          script = "_DEBUG = true " .. script
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).not_to_match_error "\n%S+:4:.*deprecated"
      - it warns only on first call with _DEBUG.compat unset:
          script = "_DEBUG = {} " .. script
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).not_to_match_error "\n%S+:4:.*deprecated"
      - it does not warn at all when set to false: |
          script = "_DEBUG = false " .. script
          expect (luaproc (script)).not_to_match_error "%d:.*deprecated"
      - it does not warn at all when compat field is set to true: |
          script = "_DEBUG = { compat = true } " .. script
          expect (luaproc (script)).not_to_match_error "%d:.*deprecated"
      - it warns on every call with compat field set to false:
          script = "_DEBUG = { compat = false } " .. script
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).to_match_error "\n%S+:4:.*deprecated"


- describe export:
  - before: |
      function mkstack (name, spec)
        return string.format ([[
          local export = require "std.base".export       -- line 1
          local function caller ()                       -- line 2
            export ({%s}, "%s", function () end)         -- line 3
          end                                            -- line 4
          caller ()                                      -- line 5
        ]], tostring (name), tostring (spec))
      end

      f, badarg = init (M, this_module, "export")

      mkmagic = function () return "MAGIC" end
      local inner = mkmagic
      wrapped = f "inner ()"

  - it returns the wrapped function:
      expect (wrapped).not_to_be (inner)
      expect (wrapped ()).to_be "MAGIC"
  - it does not wrap the function when _ARGCHECK is disabled: |
      script = [[
        _DEBUG = false
        local debug = require "std.debug_init"
        local export = require "std.base".export
        local function inner () return "MAGIC" end
        local wrapped = export "inner (any?)"
        os.exit (wrapped == inner and 0 or 1)
      ]]
      expect (luaproc (script)).to_succeed ()

  - context when checking zero argument function:
    - before:
        _, badarg = init (M, "", "inner")
    - it diagnoses too many arguments:
        expect (wrapped (false)).to_raise (badarg (1))
    - it accepts correct argument types:
        expect (wrapped ()).to_be "MAGIC"

  - context when checking single argument function:
    - before:
        _, badarg = init (M, "", "inner")
        local inner = mkmagic
        wrapped = f "inner (#table)"
    - it diagnoses missing arguments:
        expect (wrapped ()).to_raise (badarg (1, "non-empty table"))
    - it diagnoses wrong argument types:
        expect (wrapped {}).to_raise (badarg (1, "non-empty table", "empty table"))
    - it diagnoses too many arguments:
        expect (wrapped ({1}, 2, nop, "", false)).to_raise (badarg (1, 5))
    - it accepts correct argument types:
        expect (wrapped ({1})).to_be "MAGIC"

  - context when checking multi-argument function:
    - before:
        _, badarg = init (M, "", "inner")
        local inner = mkmagic
        wrapped = f "inner (table, function)"
    - it diagnoses missing arguments:
        expect (wrapped ()).to_raise (badarg (1, "table"))
        expect (wrapped ({})).to_raise (badarg (2, "function"))
    - it diagnoses wrong argument types:
        expect (wrapped (false)).to_raise (badarg (1, "table", "boolean"))
        expect (wrapped ({}, false)).to_raise (badarg (2, "function", "boolean"))
    - it diagnoses too many arguments:
        expect (wrapped ({}, nop, false)).to_raise (badarg (3))
    - it accepts correct argument types:
        expect (wrapped ({}, nop)).to_be "MAGIC"

  - context when checking optional argument function:
    - before:
        _, badarg = init (M, "", "inner")
        local inner = mkmagic
        wrapped = f "inner ([int])"
    - it diagnoses wrong argument types:
        expect (wrapped (false)).to_raise (badarg (1, "int or nil", "boolean"))
    - it diagnoses too many arguments:
        expect (wrapped (1, nop)).to_raise (badarg (2))
    - it accepts correct argument types:
        expect (wrapped ()).to_be "MAGIC"
        expect (wrapped (1)).to_be "MAGIC"

  - context when checking optional multi-argument function:
    - before:
        _, badarg = init (M, "", "inner")
        local inner = mkmagic
        wrapped = f "inner ([int], string)"
    - it diagnoses missing arguments:
        expect (wrapped ()).to_raise (badarg (1, "int or string"))
        expect (wrapped (1)).to_raise (badarg (2, "string"))
    - it diagnoses wrong argument types:
        expect (wrapped (false)).to_raise (badarg (1, "int or string", "boolean"))
    - it diagnoses too many arguments:
        expect (wrapped (1, "two", nop)).to_raise (badarg (3))
    - it accepts correct argument types:
        expect (wrapped ("two")).to_be "MAGIC"
        expect (wrapped (1, "two")).to_be "MAGIC"
