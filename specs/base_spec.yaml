before:
  this_module = "std.base"

  M = require (this_module)

  nop = M.nop

specify std.base:
- describe DEPRECATED:
  - before: |
      function runscript (body, name, args)
        return luaproc (
          "require 'std.base'.DEPRECATED ('0', '" .. (name or "runscript") .. "', function (...)" ..
          " " .. body ..
          " end) " ..
          "('" .. table.concat (args or {}, "', '") .. "')"
        )
      end

      fname = "DEPRECATED"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
      expect (f "version").to_error (msg (2, "string"))
      expect (f ("version", "name")).to_error (msg (3, "string or function"))
      expect (f ("version", "name", "extramsg")).to_error (msg (4, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
      expect (f ("version", false)).to_error (msg (2, "string", "boolean"))
      expect (f ("version", "name", false)).
        to_error (msg (3, "string or function", "boolean"))
      expect (f ("version", "name", "extramsg", false)).
        to_error (msg (4, "function", "boolean"))
  - it diagnoses too many arguments: |
      expect (f ("version", "name", "extramsg", nop, false)).
        to_error (toomanyarg (this_module, fname, 4, 5))
      pending "issue #76"
      expect (f ("version", "name", nop, false)).
        to_error (toomanyarg (this_module, fname, 3, 4))

  - it returns a function:
      expect (type (f ("0", "deprecated", nop))).to_be "function"
      expect (f ("0", "deprecated", nop)).not_to_be (nop)
  - context with deprecated function:
    - it executes the deprecated function:
        expect (runscript 'error "oh noes!"').to_contain_error "oh noes!"
    - it passes arguments to the deprecated function:
        expect (runscript ("print (table.concat ({...}, ', '))", nil,
                           {"foo", "bar", "baz"})).to_output "foo, bar, baz\n"
    - it returns deprecated function results: |
        script = [[
          DEPRECATED = require "std.base".DEPRECATED
          fn = DEPRECATED ("0", "fn", function () return "foo", "bar", "baz" end)
          print (fn ())
        ]]
        expect (luaproc (script)).to_output "foo\tbar\tbaz\n"
    - it writes a warning to stderr:
        expect (runscript 'error "oh noes!"').
          to_match_error "deprecated.*, and will be removed"
    - it writes the version string to stderr:
        expect (runscript 'error "oh noes!"').
          to_contain_error "in release 0"
    - it writes the call location to stderr: |
        expect (runscript 'error "oh noes!"').
          to_match_error "^%S+:1: "
    - context with _DEBUG:
      - before: |
          script = [[
            DEPRECATED = require "std.base".DEPRECATED
            fn = DEPRECATED ("0", "fn", function () io.stderr:write "oh noes!\n" end)
            fn ()  -- line 3
            fn ()  -- line 4
          ]]
      - it warns only on first call by default:
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).not_to_match_error "\n%S+:4:.*deprecated"
      - it warns only on first call with _DEBUG set to true:
          script = "_DEBUG = true " .. script
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).not_to_match_error "\n%S+:4:.*deprecated"
      - it warns only on first call with _DEBUG.compat unset:
          script = "_DEBUG = {} " .. script
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).not_to_match_error "\n%S+:4:.*deprecated"
      - it does not warn at all when set to false: |
          script = "_DEBUG = false " .. script
          expect (luaproc (script)).not_to_match_error "%d:.*deprecated"
      - it does not warn at all when compat field is set to true: |
          script = "_DEBUG = { compat = true } " .. script
          expect (luaproc (script)).not_to_match_error "%d:.*deprecated"
      - it warns on every call with compat field set to false:
          script = "_DEBUG = { compat = false } " .. script
          expect (luaproc (script)).to_match_error "^%S+:3:.*deprecated"
          expect (luaproc (script)).to_match_error "\n%S+:4:.*deprecated"


- describe export:
  - before:
      function mkstack (level, types)
        return string.format ([[
          _DEBUG = %s                                    -- line 1
          local export = require "std.base".export       -- line 2
          export ("ohnoes", 1, "table", t, %s) -- line 4
          end                                            -- line 5
          function caller ()                             -- line 6
            local r = ohnoes "not a table"               -- line 7
            return "not a tail call"                     -- line 8
          end                                            -- line 9
          caller ()                                      -- line 10
        ]], tostring (debugp), tostring (level))
      end

      mkmagic = function () return "MAGIC" end

      fname = "export"
      msg = function (...) return badarg (this_module, fname, ...) end
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
      expect (f ({})).to_error (msg (2, "string"))
      expect (f ({}, "")).to_error (msg (3, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
      expect (f ({}, false)).to_error (msg (2, "string", "boolean"))
      expect (f ({}, "", false)).to_error (msg (3, "function", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, "", function () end, false)).
        to_error (toomanyarg (this_module, fname, 3, 4))
  - it diagnoses missing module name element:
      expect (f ({}, "", function () end)).
        to_error (msg (1, "module name at index 1"))
  - it diagnoses malformed declaration string: |
      M = { "base_spec.yaml" }
      expect (f (M, "", function () end)).to_error "function name expected"
      expect (f (M, "woo", function () end)).
        to_error "argument type specifications expected"
      expect (f (M, "woo ()", function () end)).
        to_error (msg (2, "at least 1 argument type", "0"))

  - it returns the supplied function:
      M = { "base_spec.yaml" }
      expect (f (M, "expect (any)", f)).to_be (f)
  - it stores a function in supplied table at the specified key:
      M = { "base_spec.yaml" }
      f (M, "export (any?)", mkmagic)
      expect (M.export ()).to_be "MAGIC"
  - it stores the passed function when _ARGCHECK is disabled: |
      script = [[
        _DEBUG = false
        local debug = require "std.debug_init"
        local export = require "std.base".export
        M = { "base_spec.yaml" }
        export (M, "export (any)", export)
        os.exit (M.export == export and 0 or 1)
      ]]
      expect (luaproc (script)).to_succeed ()
  - context when checking single argument function:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module }
        fname = "chk_function"
        msg = function (...) return badarg (fake_module, fname, ...) end
        f (M, "chk_function (#table)", mkmagic)
        chk = M[fname]
    - it diagnoses missing arguments:
        expect (chk ()).to_error (msg (1, "non-empty table"))
    - it diagnoses wrong argument types:
        expect (chk {}).to_error (msg (1, "non-empty table", "empty table"))
    - it diagnoses too many arguments:
        expect (chk ({1}, 2, nop, "", false)).
          to_error (toomanyarg (fake_module, fname, 1, 5))
    - it accepts correct argument types:
        expect (chk ({1})).to_be "MAGIC"
  - context when checking multi-argument function:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module }
        fname = "chk_function"
        msg = function (...) return badarg (fake_module, fname, ...) end
        f (M, "chk_function (table, function)", mkmagic)
        chk = M[fname]
    - it diagnoses missing arguments:
        expect (chk ()).to_error (msg (1, "table"))
        expect (chk ({})).to_error (msg (2, "function"))
    - it diagnoses wrong argument types:
        expect (chk (false)).to_error (msg (1, "table", "boolean"))
        expect (chk ({}, false)).to_error (msg (2, "function", "boolean"))
    - it diagnoses too many arguments:
        expect (chk ({}, nop, false)).
          to_error (toomanyarg (fake_module, fname, 2, 3))
    - it accepts correct argument types:
        expect (chk ({}, nop)).to_be "MAGIC"
  - context when checking optional argument function:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module }
        fname = "chk_function"
        msg = function (...) return badarg (fake_module, fname, ...) end
        f (M, "chk_function ([int])", mkmagic)
        chk = M[fname]
    - it diagnoses wrong argument types:
        expect (chk (false)).to_error (msg (1, "int or nil", "boolean"))
    - it diagnoses too many arguments:
        expect (chk (1, nop)).
          to_error (toomanyarg (fake_module, fname, 1, 2))
    - it accepts correct argument types:
        expect (chk ()).to_be "MAGIC"
        expect (chk (1)).to_be "MAGIC"
  - context when checking optional multi-argument function:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module }
        fname = "chk_function"
        msg = function (...) return badarg (fake_module, fname, ...) end
        f (M, "chk_function ([int], string)", mkmagic)
        chk = M[fname]
    - it diagnoses missing arguments:
        expect (chk ()).to_error (msg (1, "int or string"))
        expect (chk (1)).to_error (msg (2, "string"))
    - it diagnoses wrong argument types:
        expect (chk (false)).to_error (msg (1, "int or string", "boolean"))
    - it diagnoses too many arguments:
        expect (chk (1, "two", nop)).
          to_error (toomanyarg (fake_module, fname, 2, 3))
    - it accepts correct argument types:
        expect (chk ("two")).to_be "MAGIC"
        expect (chk (1, "two")).to_be "MAGIC"
  - context when checking self on an object method:
    - before:
        fake_module = "base_spec.yaml"
        M = { fake_module, "Object" }
        fname = "chk_method"
        msg = function (...)
                return badarg (nil, fake_module .. ":" .. fname, ...)
              end
        f (M, "chk_method (string)", function (self, x) return x end)
        Object = require "std.object" {}
        Bad = Object { _type = "Bad" }
        obj = Object { chk = M.chk_method }
    - it diagnoses missing arguments:
        expect (obj.chk ()).to_error (msg (0, "Object"))
        expect (obj:chk ()).to_error (msg (1, "string"))
    - it diagnoses wrong argument types:
        expect (obj.chk ({})).to_error (msg (0, "Object", "empty table"))
        expect (obj.chk (Bad)).to_error (msg (0, "Object", "Bad"))
        expect (obj:chk ({})).to_error (msg (1, "string", "empty table"))
        expect (obj:chk (obj)).to_error (msg (1, "string", "Object"))
    - it diagnoses too many arguments:
        expect (obj.chk (obj, "str", false)).
          to_error (toomanyarg (nil, fake_module .. ":" .. fname, 1, 2))
        expect (obj:chk ("str", false)).
          to_error (toomanyarg (nil, fake_module .. ":" .. fname, 1, 2))
    - it accepts correct argument types:
        expect (obj.chk (obj, "str")).to_be "str"
        expect (obj.chk (Object, "str")).to_be "str"
        expect (obj:chk ("str")).to_be "str"
