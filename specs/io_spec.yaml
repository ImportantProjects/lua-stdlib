before: |
  base_module        = "io"
  this_module        = "std.io"
  global_table       = "_G"

  extend_base        = { "catdir", "catfile", "die", "monkey_patch",
                         "process_files", "readlines", "shell", "slurp",
                         "splitdir", "warn", "writelines" }

  M = require (this_module)

specify std.io:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}
    - it does not touch the core io table:
        expect (show_apis {added_to=base_module, by=this_module}).
          to_equal {}
    - it contains apis from the core io table:
        expect (show_apis {from=base_module, not_in=this_module}).
          to_contain.a_permutation_of (extend_base)

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}
    - it does not touch the core io table:
        expect (show_apis {added_to=base_module, by="std"}).
          to_equal {}


- describe catdir:
  - it diagnoses wrong argument types: |
      expect (M.catdir (false)).
        to_error "bad argument #1 to 'std.io.catdir' (string expected, got boolean)"
      expect (M.catdir ("", false)).
        to_error "bad argument #2 to 'std.io.catdir' (string expected, got boolean)"
      expect (M.catdir ("", "false", false)).
        to_error "bad argument #3 to 'std.io.catdir' (string expected, got boolean)"


- describe catfile:
  - it diagnoses wrong argument types: |
      expect (M.catfile (false)).
        to_error "bad argument #1 to 'std.io.catfile' (string expected, got boolean)"
      expect (M.catfile ("", false)).
        to_error "bad argument #2 to 'std.io.catfile' (string expected, got boolean)"
      expect (M.catfile ("", "false", false)).
        to_error "bad argument #3 to 'std.io.catfile' (string expected, got boolean)"


- describe die:
  - before:
      script = [[require "std.io".die "By 'eck!"]]
  - it diagnoses missing arguments: |
      expect (M.die ()).
        to_error "bad argument #1 to 'std.io.die' (string expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.die (false)).
        to_error "bad argument #1 to 'std.io.die' (string expected, got boolean)"
  - it outputs a message to stderr:
      expect (luaproc (script)).to_fail_with "By 'eck!\n"
  - it ignores `prog.line` without `prog.file` or `prog.name`:
      script = [[prog = { line = 125 };]] .. script
      expect (luaproc (script)).to_fail_with "By 'eck!\n"
  - it ignores `opts.line` without `opts.program`:
      script = [[opts = { line = 99 };]] .. script
      expect (luaproc (script)).to_fail_with "By 'eck!\n"
  - it prefixes `prog.name` if any: |
      script = [[prog = { name = "name" };]] .. script
      expect (luaproc (script)).to_fail_with "name: By 'eck!\n"
  - it appends `prog.line` if any, to `prog.name`: |
      script = [[prog = { line = 125, name = "name" };]] .. script
      expect (luaproc (script)).to_fail_with "name:125: By 'eck!\n"
  - it prefixes `prog.file` if any: |
      script = [[prog = { file = "file" };]] .. script
      expect (luaproc (script)).to_fail_with "file: By 'eck!\n"
  - it appends `prog.line` if any, to `prog.name`: |
      script = [[prog = { file = "file", line = 125 };]] .. script
      expect (luaproc (script)).to_fail_with "file:125: By 'eck!\n"
  - it prefers `prog.name` to `prog.file` or `opts.program`: |
      script = [[
        prog = { file = "file", name = "name" }
        opts = { program = "program" }
      ]] .. script
      expect (luaproc (script)).to_fail_with "name: By 'eck!\n"
  - it appends `prog.line` if any to `prog.name` over anything else: |
      script = [[
        prog = { file = "file", line = 125, name = "name" }
        opts = { line = 99, program = "program" }
      ]] .. script
      expect (luaproc (script)).to_fail_with "name:125: By 'eck!\n"
  - it prefers `prog.file` to `opts.program`: |
      script = [[
        prog = { file = "file" }; opts = { program = "program" }
      ]] .. script
      expect (luaproc (script)).to_fail_with "file: By 'eck!\n"
  - it appends `prog.line` if any to `prog.file` over using `opts`: |
      script = [[
        prog = { file = "file", line = 125 }
        opts = { line = 99, program = "program" }
      ]] .. script
      expect (luaproc (script)).to_fail_with "file:125: By 'eck!\n"
  - it prefixes `opts.program` if any: |
      script = [[opts = { program = "program" };]] .. script
      expect (luaproc (script)).to_fail_with "program: By 'eck!\n"
  - it appends `opts.line` if any, to `opts.program`: |
      script = [[opts = { line = 99, program = "program" };]] .. script
      expect (luaproc (script)).to_fail_with "program:99: By 'eck!\n"


- describe monkey_patch:
  - before:
      f  = M.monkey_patch
      mt = {}
      t  = {
        io = {
          stdin  = setmetatable ({}, mt),
          stdout = setmetatable ({}, mt),
          stderr = setmetatable ({}, mt),
        },
      }
  - it diagnoses missing arguments: |
      expect (M.monkey_patch ()).
        to_error "bad argument #1 to 'std.io.monkey_patch' (table expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.monkey_patch (false)).
        to_error "bad argument #1 to 'std.io.monkey_patch' (table expected, got boolean)"
  - it installs readlines metamethod:
      f (t)
      expect (mt.readlines).to_be (M.readlines)
  - it installs writelines metamethod:
      f (t)
      expect (mt.writelines).to_be (M.writelines)
  - it diagnoses non-table argument:
      expect (f "bad").to_error "table expected"


- describe process_files:
  - it diagnoses missing arguments: |
      expect (M.process_files ()).
        to_error "bad argument #1 to 'std.io.process_files' (function expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.process_files (false)).
        to_error "bad argument #1 to 'std.io.process_files' (function expected, got boolean)"


- describe readlines:
  - it diagnoses wrong argument types: |
      expect (M.readlines (false)).
        to_error "bad argument #1 to 'std.io.readlines' (file, string or nil expected, got boolean)"


- describe shell:
  - it diagnoses missing arguments: |
      expect (M.shell ()).
        to_error "bad argument #1 to 'std.io.shell' (string expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.shell (false)).
        to_error "bad argument #1 to 'std.io.shell' (string expected, got boolean)"


- describe slurp:
  - it diagnoses wrong argument types: |
      expect (M.slurp (false)).
        to_error "bad argument #1 to 'std.io.slurp' (file, string or nil expected, got boolean)"


- describe splitdir:
  - it diagnoses missing arguments: |
      expect (M.splitdir ()).
        to_error "bad argument #1 to 'std.io.splitdir' (string expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.splitdir (false)).
        to_error "bad argument #1 to 'std.io.splitdir' (string expected, got boolean)"


- describe warn:
  - before:
      script = [[require "std.io".warn "Ayup!"]]
  - it diagnoses missing arguments: |
      expect (M.warn ()).
        to_error "bad argument #1 to 'std.io.warn' (string expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (M.warn (false)).
        to_error "bad argument #1 to 'std.io.warn' (string expected, got boolean)"
  - it outputs a message to stderr:
      expect (luaproc (script)).to_output_error "Ayup!\n"
  - it ignores `prog.line` without `prog.file`, `prog.name` or `opts.program`:
      script = [[prog = { line = 125 };]] .. script
      expect (luaproc (script)).to_output_error "Ayup!\n"
  - it prefixes `prog.name` if any: |
      script = [[prog = { name = "name" };]] .. script
      expect (luaproc (script)).to_output_error "name: Ayup!\n"
  - it appends `prog.line` if any, to `prog.name`: |
      script = [[prog = { line = 125, name = "name" };]] .. script
      expect (luaproc (script)).to_output_error "name:125: Ayup!\n"
  - it prefixes `prog.file` if any: |
      script = [[prog = { file = "file" };]] .. script
      expect (luaproc (script)).to_output_error "file: Ayup!\n"
  - it appends `prog.line` if any, to `prog.name`: |
      script = [[prog = { file = "file", line = 125 };]] .. script
      expect (luaproc (script)).to_output_error "file:125: Ayup!\n"
  - it prefers `prog.name` to `prog.file` or `opts.program`: |
      script = [[
        prog = { file = "file", name = "name" }
        opts = { program = "program" }
      ]] .. script
      expect (luaproc (script)).to_output_error "name: Ayup!\n"
  - it appends `prog.line` if any to `prog.name` over anything else: |
      script = [[
        prog = { file = "file", line = 125, name = "name" }
        opts = { line = 99, program = "program" }
      ]] .. script
      expect (luaproc (script)).to_output_error "name:125: Ayup!\n"
  - it prefers `prog.file` to `opts.program`: |
      script = [[
        prog = { file = "file" }; opts = { program = "program" }
      ]] .. script
      expect (luaproc (script)).to_output_error "file: Ayup!\n"
  - it appends `prog.line` if any to `prog.file` over using `opts`: |
      script = [[
        prog = { file = "file", line = 125 }
        opts = { line = 99, program = "program" }
      ]] .. script
      expect (luaproc (script)).to_output_error "file:125: Ayup!\n"
  - it prefixes `opts.program` if any: |
      script = [[opts = { program = "program" };]] .. script
      expect (luaproc (script)).to_output_error "program: Ayup!\n"
  - it appends `opts.line` if any, to `opts.program`: |
      script = [[opts = { line = 99, program = "program" };]] .. script
      expect (luaproc (script)).to_output_error "program:99: Ayup!\n"


- describe writelines:
  - it diagnoses wrong argument types: |
      expect (M.writelines (false)).
        to_error "bad argument #1 to 'std.io.writelines' (file, string or nil expected, got boolean)"
