before: |
  base_module        = "io"
  this_module        = "std.io"
  global_table       = "_G"

  extend_base        = { "catdir", "catfile", "die", "monkey_patch",
                         "process_files", "readlines", "shell", "slurp",
                         "splitdir", "warn", "writelines" }

  dirsep = string.match (package.config, "^([^\n]+)\n")

  M = require (this_module)

specify std.io:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}
    - it does not touch the core io table:
        expect (show_apis {added_to=base_module, by=this_module}).
          to_equal {}
    - it contains apis from the core io table:
        expect (show_apis {from=base_module, not_in=this_module}).
          to_contain.a_permutation_of (extend_base)

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}
    - it does not touch the core io table:
        expect (show_apis {added_to=base_module, by="std"}).
          to_equal {}


- describe catdir:
  - before: |
      fname = "catdir"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
      expect (f ("", false)).to_error (msg (2, "string", "boolean"))
      expect (f ("", "false", false)).to_error (msg (3, "string", "boolean"))

  - it treats initial empty string as root directory:
      expect (f ("")).to_be (dirsep)
      expect (f ("", "")).to_be (dirsep)
      expect (f ("", "root")).to_be (dirsep .. "root")
  - it returns a single argument unchanged:
      expect (f ("hello")).to_be "hello"
  - it joins multiple arguments with platform directory separator:
      expect (f ("one", "two")).to_be ("one" .. dirsep .. "two")
      expect (f ("1", "2", "3", "4", "5")).
        to_be (table.concat ({"1", "2", "3", "4", "5"}, dirsep))


- describe catfile:
  - before:
      fname = "catfile"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
      expect (f ("", false)).to_error (msg (2, "string", "boolean"))
      expect (f ("", "false", false)).to_error (msg (3, "string", "boolean"))

  - it treats initial empty string as root directory:
      expect (f ("", "")).to_be (dirsep)
      expect (f ("", "root")).to_be (dirsep .. "root")
  - it returns a single argument unchanged:
      expect (f ("")).to_be ""
      expect (f ("hello")).to_be "hello"
  - it joins multiple arguments with platform directory separator:
      expect (f ("one", "two")).to_be ("one" .. dirsep .. "two")
      expect (f ("1", "2", "3", "4", "5")).
        to_be (table.concat ({"1", "2", "3", "4", "5"}, dirsep))


- describe die:
  - before: |
      script = [[require "std.io".die "By 'eck!"]]

      fname = "die"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))

  - it outputs a message to stderr:
      expect (luaproc (script)).to_fail_with "By 'eck!\n"
  - it ignores `prog.line` without `prog.file` or `prog.name`:
      script = [[prog = { line = 125 };]] .. script
      expect (luaproc (script)).to_fail_with "By 'eck!\n"
  - it ignores `opts.line` without `opts.program`:
      script = [[opts = { line = 99 };]] .. script
      expect (luaproc (script)).to_fail_with "By 'eck!\n"
  - it prefixes `prog.name` if any: |
      script = [[prog = { name = "name" };]] .. script
      expect (luaproc (script)).to_fail_with "name: By 'eck!\n"
  - it appends `prog.line` if any, to `prog.name`: |
      script = [[prog = { line = 125, name = "name" };]] .. script
      expect (luaproc (script)).to_fail_with "name:125: By 'eck!\n"
  - it prefixes `prog.file` if any: |
      script = [[prog = { file = "file" };]] .. script
      expect (luaproc (script)).to_fail_with "file: By 'eck!\n"
  - it appends `prog.line` if any, to `prog.name`: |
      script = [[prog = { file = "file", line = 125 };]] .. script
      expect (luaproc (script)).to_fail_with "file:125: By 'eck!\n"
  - it prefers `prog.name` to `prog.file` or `opts.program`: |
      script = [[
        prog = { file = "file", name = "name" }
        opts = { program = "program" }
      ]] .. script
      expect (luaproc (script)).to_fail_with "name: By 'eck!\n"
  - it appends `prog.line` if any to `prog.name` over anything else: |
      script = [[
        prog = { file = "file", line = 125, name = "name" }
        opts = { line = 99, program = "program" }
      ]] .. script
      expect (luaproc (script)).to_fail_with "name:125: By 'eck!\n"
  - it prefers `prog.file` to `opts.program`: |
      script = [[
        prog = { file = "file" }; opts = { program = "program" }
      ]] .. script
      expect (luaproc (script)).to_fail_with "file: By 'eck!\n"
  - it appends `prog.line` if any to `prog.file` over using `opts`: |
      script = [[
        prog = { file = "file", line = 125 }
        opts = { line = 99, program = "program" }
      ]] .. script
      expect (luaproc (script)).to_fail_with "file:125: By 'eck!\n"
  - it prefixes `opts.program` if any: |
      script = [[opts = { program = "program" };]] .. script
      expect (luaproc (script)).to_fail_with "program: By 'eck!\n"
  - it appends `opts.line` if any, to `opts.program`: |
      script = [[opts = { line = 99, program = "program" };]] .. script
      expect (luaproc (script)).to_fail_with "program:99: By 'eck!\n"


- describe monkey_patch:
  - before:
      mt = {}
      t  = {
        io = {
          stdin  = setmetatable ({}, mt),
          stdout = setmetatable ({}, mt),
          stderr = setmetatable ({}, mt),
        },
      }
      fname = "monkey_patch"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f (t, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it installs readlines metamethod:
      f (t)
      expect (mt.readlines).to_be (M.readlines)
  - it installs writelines metamethod:
      f (t)
      expect (mt.writelines).to_be (M.writelines)


- describe process_files:
  - before:
      name = "specs/spec_helper.lua"
      names = {"Makefile", "config.log", "config.status", "specs/spec_helper.lua"}
      ascript = [[
        require "std.io".process_files (function (a) print (a) end)
      ]]
      iscript = [[
        require "std.io".process_files (function (_, i) print (i) end)
      ]]
      catscript = [[
        require "std.io".process_files (function () io.write (io.input ():read "*a") end)
      ]]
      fname = "process_files"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
  - it diagnoses wrong argument types: |
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (luaproc (ascript, "not-an-existing-file")).to_contain_error.any_of {
        "cannot open file 'not-an-existing-file'",            -- Lua 5.2
        "bad argument #1 to 'input' (not-an-existing-file:",  -- Lua 5.1
      }
  - it diagnoses too many arguments:
      expect (f (f, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it defaults to `-` if no arguments were passed:
      expect (luaproc (ascript)).to_output "-\n"
  - it iterates over arguments with supplied function:
      expect (luaproc (ascript, name)).to_output (name .. "\n")
      expect (luaproc (ascript, names)).
        to_output (table.concat (names, "\n") .. "\n")
  - it passes argument numbers to supplied function:
      expect (luaproc (iscript, names)).to_output "1\n2\n3\n4\n"
  - it sets each file argument as the default input:
      expect (luaproc (catscript, name)).to_output (concat_file_content (name))
      expect (luaproc (catscript, names)).
        to_output (concat_file_content (unpack (names)))
  - it processes io.stdin if no arguments were passed:
      ## FIXME: where does that closing newline come from??
      expect (luaproc (catscript, nil, "some\nlines\nof input")).to_output "some\nlines\nof input\n"
  - it processes io.stdin for `-` argument:
      ## FIXME: where does that closing newline come from??
      expect (luaproc (catscript, "-", "some\nlines\nof input")).to_output "some\nlines\nof input\n"


- describe readlines:
  - before: |
      name = "specs/spec_helper.lua"
      h = io.open (name)
      lines = {} for l in h:lines () do lines[#lines + 1] = l end
      h:close ()

      defaultin = io.input ()
      fname = "readlines"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]
  - after:
      if io.type (defaultin) ~= "closed file" then io.input (defaultin) end

  - it diagnoses wrong argument types: |
      expect (f (false)).to_error (msg (1, "file, string or nil", "boolean"))
      expect (f "not-an-existing-file").
        to_error "bad argument #1 to 'std.io.readlines' (" -- system dependent error message
  - it diagnoses closed file argument:
      closed = io.open (name, "r") closed:close ()
      expect (f (closed)).
        to_error (msg (1, "file, string or nil", "closed file"))
  - it diagnoses too many arguments:
      expect (f ("string", false)).
        to_error (toomanyarg (this_module, fname, 1, 2))

  - it closes file handle upon completion:
      h = io.open (name)
      expect (io.type (h)).not_to_be "closed file"
      f (h)
      expect (io.type (h)).to_be "closed file"
  - it reads lines from an existing named file:
      expect (f (name)).to_equal (lines)
  - it reads lines from an open file handle:
      expect (f (io.open (name))).to_equal (lines)
  - it reads from default input stream with no arguments:
      io.input (name)
      expect (f ()).to_equal (lines)


- describe shell:
  - before:
      fname = "shell"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
  - it diagnoses too many arguments:
      expect (f ("string", false)).
        to_error (toomanyarg (this_module, fname, 1, 2))

  - it returns the output from a shell command string:
      expect (f [[printf '%s\n' 'foo' 'bar']]).to_be "foo\nbar\n"


- describe slurp:
  - before: |
      name = "specs/spec_helper.lua"
      h = io.open (name)
      content = h:read "*a"
      h:close ()

      defaultin = io.input ()
      fname = "slurp"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]
  - after:
      if io.type (defaultin) ~= "closed file" then io.input (defaultin) end

  - it diagnoses wrong argument types: |
      expect (f (false)).to_error (msg (1, "file, string or nil", "boolean"))
      expect (f "not-an-existing-file").
        to_error "bad argument #1 to 'std.io.slurp' (" -- system dependent error message
  - it diagnoses closed file argument:
      closed = io.open (name, "r") closed:close ()
      expect (f (closed)).
        to_error (msg (1, "file, string or nil", "closed file"))
  - it diagnoses too many arguments:
      expect (f ("string", false)).
        to_error (toomanyarg (this_module, fname, 1, 2))

  - it reads content from an existing named file:
      expect (f (name)).to_be (content)
  - it reads content from an open file handle:
      expect (f (io.open (name))).to_be (content)
  - it closes file handle upon completion:
      h = io.open (name)
      expect (io.type (h)).not_to_be "closed file"
      f (h)
      expect (io.type (h)).to_be "closed file"
  - it reads from default input stream with no arguments:
      io.input (name)
      expect (f ()).to_be (content)


- describe splitdir:
  - before:
      fname = "splitdir"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
  - it diagnoses too many arguments:
      expect (f ("string", false)).
        to_error (toomanyarg (this_module, fname, 1, 2))

  - it returns a filename as a one element list:
      expect (f ("hello")).to_equal {"hello"}
  - it splits root directory in two empty elements:
      expect (f (dirsep)).to_equal {"", ""}
  - it returns initial empty string for absolute path:
      expect (f (dirsep .. "root")).to_equal {"", "root"}
  - it returns multiple components split at platform directory separator:
      expect (f ("one" .. dirsep .. "two")).to_equal {"one", "two"}
      expect (f (table.concat ({"1", "2", "3", "4", "5"}, dirsep))).
        to_equal {"1", "2", "3", "4", "5"}


- describe warn:
  - before:
      script = [[require "std.io".warn "Ayup!"]]
      fname = "warn"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))

  - it outputs a message to stderr:
      expect (luaproc (script)).to_output_error "Ayup!\n"
  - it ignores `prog.line` without `prog.file`, `prog.name` or `opts.program`:
      script = [[prog = { line = 125 };]] .. script
      expect (luaproc (script)).to_output_error "Ayup!\n"
  - it prefixes `prog.name` if any: |
      script = [[prog = { name = "name" };]] .. script
      expect (luaproc (script)).to_output_error "name: Ayup!\n"
  - it appends `prog.line` if any, to `prog.name`: |
      script = [[prog = { line = 125, name = "name" };]] .. script
      expect (luaproc (script)).to_output_error "name:125: Ayup!\n"
  - it prefixes `prog.file` if any: |
      script = [[prog = { file = "file" };]] .. script
      expect (luaproc (script)).to_output_error "file: Ayup!\n"
  - it appends `prog.line` if any, to `prog.name`: |
      script = [[prog = { file = "file", line = 125 };]] .. script
      expect (luaproc (script)).to_output_error "file:125: Ayup!\n"
  - it prefers `prog.name` to `prog.file` or `opts.program`: |
      script = [[
        prog = { file = "file", name = "name" }
        opts = { program = "program" }
      ]] .. script
      expect (luaproc (script)).to_output_error "name: Ayup!\n"
  - it appends `prog.line` if any to `prog.name` over anything else: |
      script = [[
        prog = { file = "file", line = 125, name = "name" }
        opts = { line = 99, program = "program" }
      ]] .. script
      expect (luaproc (script)).to_output_error "name:125: Ayup!\n"
  - it prefers `prog.file` to `opts.program`: |
      script = [[
        prog = { file = "file" }; opts = { program = "program" }
      ]] .. script
      expect (luaproc (script)).to_output_error "file: Ayup!\n"
  - it appends `prog.line` if any to `prog.file` over using `opts`: |
      script = [[
        prog = { file = "file", line = 125 }
        opts = { line = 99, program = "program" }
      ]] .. script
      expect (luaproc (script)).to_output_error "file:125: Ayup!\n"
  - it prefixes `opts.program` if any: |
      script = [[opts = { program = "program" };]] .. script
      expect (luaproc (script)).to_output_error "program: Ayup!\n"
  - it appends `opts.line` if any, to `opts.program`: |
      script = [[opts = { line = 99, program = "program" };]] .. script
      expect (luaproc (script)).to_output_error "program:99: Ayup!\n"


- describe writelines:
  - before: |
      name = os.tmpname ()
      h = io.open (name, "w")
      lines = M.readlines (io.open "specs/spec_helper.lua")

      defaultout = io.output ()
      fname = "writelines"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]
  - after:
      if io.type (defaultout) ~= "closed file" then io.output (defaultout) end
      h:close ()
      os.remove (name)

  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error (msg (1, "file, string, number or nil", "boolean"))
  - it diagnoses closed file argument: |
      closed = io.open (name) closed:close ()
      expect (f (closed)).
        to_error (msg (1, "file, string, number or nil", "closed file"))

  - it does not close the file handle upon completion:
      expect (io.type (h)).not_to_be "closed file"
      f (h, "foo")
      expect (io.type (h)).not_to_be "closed file"
  - it writes lines to an open file handle:
      f (h, unpack (lines))
      h:flush ()
      expect (M.readlines (io.open (name))).to_equal (lines)
  - it accepts number valued arguments:
      f (h, 1, 2, 3)
      h:flush ()
      expect (M.readlines (io.open (name))).to_equal {"1", "2", "3"}
  - it writes to default output stream with non-file first argument:
      io.output (h)
      f (unpack (lines))
      h:flush ()
      expect (M.readlines (io.open (name))).to_equal (lines)
