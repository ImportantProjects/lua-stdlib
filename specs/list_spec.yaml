before:
  this_module  = "std.list"
  global_table = "_G"

  exported_apis = { 1, "append", "compare", "concat", "cons", "depair",
                    "elems", "enpair", "filter", "flatten", "foldl",
                    "foldr", "index_key", "index_value", "map",
                    "map_with", "project", "relems", "rep", "reverse",
                    "shape", "sub", "tail", "transpose", "zip_with" }

  M = require (this_module)

  List    = M {}
  l       = List {"foo", "bar", "baz"}


specify std.list:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to="_G", by="std.list"}).
          to_equal {}
    - it exports the documented apis:
        t = {}
        for k in pairs (M) do t[#t + 1] = k end
        expect (t).to_contain.a_permutation_of (exported_apis)

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}

- describe construction:
  - context from List clone method:
    - it constructs a new list:
        l = List:clone {}
        expect (l).not_to_be (List)
        expect (prototype (l)).to_be "List"
    - it reuses the List metatable:
        l, m = List:clone {"l"}, List:clone {"m"}
        expect (getmetatable (l)).to_be (getmetatable (m))
    - it initialises List with constructor parameters:
        m = List:clone {"foo", "bar", "baz"}
        expect (m).to_equal (l)
    - it serves as a prototype for new instances:
        m = l:clone {}
        expect (prototype (m)).to_be "List"
        expect (m).to_equal (l)
        expect (getmetatable (m)).to_be (getmetatable (l))

  # List {args} is just syntactic sugar for List:clone {args}
  - context from List object prototype:
    - it constructs a new list:
        l = List {}
        expect (l).not_to_be (List)
        expect (prototype (l)).to_be "List"
    - it reuses the List metatable:
        l, m = List {"l"}, List {"m"}
        expect (getmetatable (l)).to_be (getmetatable (m))
    - it initialises list with constructor parameters:
        m = List {"foo", "bar", "baz"}
        expect (m).to_equal (l)
    - it serves as a prototype for new instances:
        m = l {}
        expect (prototype (m)).to_be "List"
        expect (m).to_equal (l)
        expect (getmetatable (m)).to_be (getmetatable (l))


- describe metatable propagation:
  - it reuses the metatable for List constructed objects:
      m = List {"foo", "bar"}
      expect (getmetatable (m)).to_be (getmetatable (l))


- describe append:
  - before:
      fname = "append"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "List"))
      expect (f (l)).to_error (msg (2, "any value"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "List", "boolean"))
  - it diagnoses too many arguments:
      expect (f (l, 42, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - context when called as a list object method:
    - it returns a list object:
        l = l:append ("quux")
        expect (prototype (l)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:append ("quux")).to_equal (List {"quux"})
    - it appends an item to a list:
        expect (l:append ("quux")).
          to_equal (List {"foo", "bar", "baz", "quux"})
  - context when called as a list metamethod:
    - it returns a list object:
        l = l + "quux"
        expect (prototype (l)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l + "quux").to_equal (List {"quux"})
    - it appends an item to a list:
        expect (l + "quux").
          to_equal (List {"foo", "bar", "baz", "quux"})


- describe compare:
  - before:
      a, b = List {"foo", "bar"}, List {"foo", "baz"}

      fname = "compare"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "List"))
      expect (f (l)).to_error (msg (2, "List or table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "List", "boolean"))
      expect (f (a, false)).to_error (msg (2, "List or table", "boolean"))
  - it diagnoses too many arguments:
      expect (f (a, b, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - context when called as a list object method:
    - it returns -1 when the first list is less than the second: |
        expect (a:compare {"foo", "baz"}).to_be (-1)
        expect (a:compare (List {"foo", "baz"})).to_be (-1)
    - it returns -1 when the second list has additional elements: |
        b = List {"foo"}
        expect (b:compare {"foo", "bar"}).to_be (-1)
        expect (List {"foo"}:compare (List {"foo", "bar"})).to_be (-1)
    - it returns 0 when two lists are the same: |
        expect (a:compare {"foo", "bar"}).to_be (0)
        expect (a:compare (List {"foo", "bar"})).to_be (0)
    - it returns +1 when the first list is greater than the second: |
        expect (a:compare {"baz", "quux"}).to_be (1)
        expect (a:compare (List {"baz", "quux"})).to_be (1)
    - it returns +1 when the first list has additional elements: |
        expect (a:compare {"foo"}).to_be (1)
        expect (a:compare (List {"foo"})).to_be (1)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a:compare (b)).to_be (-1)
  - context when called as a '<' list metamethod:
    - it succeeds when the first list is less than the second:
        expect (a < b).to_be (true)
    - it fails when the first list is not less than the second:
        expect (a < a).to_be (false)
        expect (b < a).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a < b).to_be (true)
  - context when called as a '>' list metamethod:
    - it succeeds when the first list is greater than the second:
        expect (b > a).to_be (true)
    - it fails when the first list is not greater than the second:
        expect (b > b).to_be (false)
        expect (a > b).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a > b).to_be (false)
  - context when called as a '<=' list metamethod:
    - it succeeds when the first list is less than or equal to the second:
        expect (a <= b).to_be (true)
        expect (a <= a).to_be (true)
    - it fails when the first list is not less than or equal to the second:
        expect (b <= a).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a <= b).to_be (true)
  - context when called as a '>=' list metamethod:
    - it succeeds when the first list is greater than or equal to the second:
        expect (b >= a).to_be (true)
        expect (b >= b).to_be (true)
    - it fails when the first list is not greater than or equal to the second:
        expect (a >= b).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a >= b).to_be (false)


- describe concat:
  - before:
      l = List {"foo", "bar"}

      fname = "concat"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "List"))
      expect (f (l)).to_error (msg (2, "List or table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "List", "boolean"))
      expect (f (l, false)).to_error (msg (2, "List or table", "boolean"))
      expect (f (l, l, false)).
        to_error (msg (3, "List or table", "boolean"))

  - context when called as a list object method:
    - it returns a list object:
        l = l:concat (List {"baz"})
        expect (prototype (l)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:concat (List {"baz"})).to_equal (List {"baz"})
    - it concatenates lists:
        expect (l:concat (List {"baz", "quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (l:concat (List {"baz"}, List {"quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
  - context when called as a list metamethod:
    - it returns a list object:
        l = l .. List {"baz"}
        expect (prototype (l)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l .. List {"baz"}).to_equal (List {"baz"})
    - it concatenates lists:
        expect (l .. List {"baz", "quux"}).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (l .. List {"baz"} .. List {"quux"}).
          to_equal (List {"foo", "bar", "baz", "quux"})


- describe cons:
  - before:
      fname = "cons"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {l, "head"})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list.cons' with list argument first was deprecated"
        end
        _, err = capture (f, {l, "head"})
        expect (err).to_be (nil)

    - it diagnoses missing arguments:
        expect (f ()).to_error (msg (1, "any value"))
    - it diagnoses wrong argument types:
        expect (f ("head", false)).to_error (msg (2, "List or nil", "boolean"))

    - it returns a list object:
        expect (prototype (f ("head", l))).to_be "List"
    - it prepends an item to a list:
        expect (f ("head", l)).
          to_equal (List {"head", "foo", "bar", "baz"})
    - it works for empty lists:
        l = List {}
        expect (f ("head", l)).to_equal (List {"head"})
    - it supports single argument call:
        expect (f "head").to_equal (List {"head"})

  - context as a list object method:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = l[fname]

    - it returns a list object:
        expect (prototype (f (l, "head"))).to_be "List"
    - it prepends an item to a list:
        expect (f (l, "head")).
          to_equal (List {"head", "foo", "bar", "baz"})
    - it works for empty lists:
        l = List {}
        expect (f (l, "head")).to_equal (List {"head"})


- describe depair:
  - before:
      t = {"first", "second", third = 4}
      l = M.enpair (t)

      fname = "depair"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it diagnoses missing arguments:
        expect (f ()).to_error (msg (1, "List"))
    - it diagnoses wrong argument types:
        expect (f (false)).to_error (msg (1, "List", "boolean"))
        expect (f (List {0})).
          to_error (msg (1, "List of Lists", "number at index 1"))
        expect (f (List {{}})).
          to_error (msg (1, "List of Lists", "empty table at index 1"))
        expect (f (List { List {"a", "b"}, ""})).
          to_error (msg (1, "List of Lists", "string at index 2"))

    - it returns a primitive table:
        expect (prototype (f (l))).to_be "table"
    - it works with an empty list:
        l = List {}
        expect (f (l)).to_equal {}
    - it is the inverse of enpair:
        expect (f (l)).to_equal (t)

  - context as a list object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:depair' was deprecated"
        end
        expect (select (2, capture (f, {l}))).to_be (nil)

    - it returns a primitive table:
        expect (prototype (l:depair ())).to_be "table"
    - it works with an empty list:
        l = List {}
        expect (l:depair ()).to_equal {}
    - it is the inverse of enpair:
        expect (l:depair ()).to_equal (t)


- describe elems:
  - before:
      fname = "elems"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {{}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list.elems' was deprecated"
        end
        expect (select (2, capture (f, {{}}))).to_be (nil)

    - it is an iterator over list members:
        t = {}
        for e in f (l) do table.insert (t, e) end
        expect (t).to_equal {"foo", "bar", "baz"}
    - it works for an empty list:
        t = {}
        for e in f (List {}) do table.insert (t, e) end
        expect (t).to_equal {}

  - context as an object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:elems' was deprecated"
        end
        _, err = capture (f, {l})
        expect (err).to_be (nil)

    - it is an iterator over list members:
        t = {}
        for e in l:elems () do table.insert (t, e) end
        expect (t).to_equal {"foo", "bar", "baz"}
    - it works for an empty list:
        t, l = {}, List {}
        for e in l:elems () do table.insert (t, e) end
        expect (t).to_equal {}


- describe enpair:
  - before:
     t = {"first", "second", third = 4}

     fname = "enpair"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it diagnoses missing arguments:
        expect (f ()).to_error (msg (1, "table"))
    - it diagnoses wrong argument types:
        expect (f (false)).to_error (msg (1, "table", "boolean"))
    - it diagnoses too many arguments:
        expect (f ({}, false)).
          to_error (toomanyarg (this_module, fname, 1, 2))

    - it returns a list object:
        expect (prototype (f (t))).to_be "List"
    - it works for an empty table:
        expect (f {}).to_equal (List {})
    - it turns a table into a list of pairs:
        expect (f (t)).
          to_equal (List {List {1, "first"}, List {2, "second"}, List {"third", 4}})


- describe filter:
  - before:
      l = List {"foo", "bar", "baz", "quux"}
      p = function (e) return (e:match "a" ~= nil) end

      fname = "filter"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments: |
      expect (f ()).to_error (msg (1, "function"))
      expect (f (p)).to_error (msg (2, "List"))
  - it diagnoses wrong argument types: |
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (f (p, false)).to_error (msg (2, "List", "boolean"))
  - it diagnoses too many arguments:
      expect (f (p, l, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - context when called as a list object method:
    - it returns a list object:
        m = l:filter (p)
        expect (prototype (m)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:filter (p)).to_equal (List {})
    - it filters a list according to a predicate:
        expect (l:filter (p)).to_equal (List {"bar", "baz"})


- describe flatten:
  - before:
      l = List {List {List {"one"}}, "two", List {List {"three"}, "four"}}

      fname = "flatten"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "List"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "List", "boolean"))
  - it diagnoses too many arguments:
      expect (f (l, false)).
        to_error (toomanyarg (this_module, fname, 1, 2))

  - context when called as a list object method:
    - it returns a list object:
        m = List.flatten (l)
        expect (prototype (m)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:flatten ()).to_equal (List {})
    - it flattens a list:
        expect (l:flatten ()).
          to_equal (List {"one", "two", "three", "four"})


- describe foldl:
  - before:
      op = require "std.operator"

      fname = "foldl"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {op["+"], 1, {10}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list.foldl' was deprecated"
        end
        _, err = capture (f, {op["+"], 1, {10}})
        expect (err).to_be (nil)

    - context with a table:
      - it works with an empty table:
          expect (f (op["+"], 10000, {})).to_be (10000)
      - it folds a binary function through a table:
          expect (f (op["+"], 10000, {1, 10, 100})).to_be (10111)
      - it folds from left to right:
          expect (f (op["^"], 2, {3, 4})).to_be ((2 ^ 3) ^ 4)

    - context with a List:
      - it works with an empty List:
          expect (f (op["+"], 10000, List {})).to_be (10000)
      - it folds a binary function through a List:
          expect (f (op["+"], 10000, List {1, 10, 100})).
            to_be (10111)
      - it folds from left to right:
          expect (f (op["^"], 2, List {3, 4})).to_be ((2 ^ 3) ^ 4)

  - context as a List object method:
    - before:
        l = List {3, 4}
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {l, op["+"], 1})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:foldl' was deprecated"
        end
        _, err = capture (f, {l, op["+"], 1})
        expect (err).to_be (nil)

    - it works with an empty list:
        l = List {}
        expect (f (l, op["+"], 2)).to_be (2)
    - it folds a binary function through a list:
        expect (f (l, op["+"], 2)).to_be (9)
    - it folds from left to right:
        expect (f (l, op["^"], 2)).to_be ((2 ^ 3) ^ 4)


- describe foldr:
  - before:
      op = require "std.operator"

      fname = "foldr"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {op["+"], 1, {10}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list.foldr' was deprecated"
        end
        _, err = capture (f, {op["+"], 1, {10}})
        expect (err).to_be (nil)

    - context with a table:
      - it works with an empty table:
          expect (f (op["+"], 10000, {})).to_be (10000)
      - it folds a binary function through a table:
          expect (f (op["+"], 10000, {1, 10, 100})).to_be (10111)
      - it folds from right to left:
          expect (f (op["/"], 10, {10000, 100})).to_be (10000 / (100 / 10))

    - context with a List:
      - it works with an empty List:
          expect (f (op["+"], 10000, List {})).to_be (10000)
      - it folds a binary function through a List:
          expect (f (op["+"], 10000, List {1, 10, 100})).
            to_be (10111)
      - it folds from right to left:
          expect (f (op["/"], 10, List {10000, 100})).
            to_be (10000 / (100 / 10))

  - context as a List object method:
    - before:
        l = List {10000, 100}
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {l, op["+"], 1})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:foldr' was deprecated"
        end
        _, err = capture (f, {l, op["+"], 1})
        expect (err).to_be (nil)

    - it works with an empty list:
        l = List {}
        expect (f (l, op["+"], 10)).to_be (10)
    - it folds a binary function through a list:
        expect (f (l, op["+"], 10)).to_be (10110)
    - it folds from right to left:
        expect (f (l, op["/"], 10)).to_be (10000 / (100 / 10))


- describe index_key:
  - before:
      fname = "index_key"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {1, List {{1}}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list.index_key' was deprecated"
        end
        _, err = capture (f, {1, List {{1}}})
        expect (err).to_be (nil)

    - it makes a map of matched table field values to table list offsets:
        l = List {{a = "b", c = "d"}, {e = "x", f = "g"}, {a = "x"}}
        t = f ("a", l)
        expect (t).to_equal {b = 1, x = 3}
        for k, v in pairs (t) do
          expect (k).to_equal (l[v]["a"])
        end
    - it captures only the last matching list offset:
        l = List {{a = "b"}, {a = "x"}, {a = "b"}}
        t = f ("a", l)
        expect (t.b).not_to_be (1)
        expect (t.x).to_be (2)
        expect (t.b).to_be (3)
    - it produces incomplete indices when faced with repeated matching table values:
        l = List {{1, 2, 3}, {2}, {2, 1, 3, 2, 1}}
        expect (f (1, l)).to_equal {1, 3}
        expect (f (2, l)).to_equal {3, 1}
        expect (f (3, l)).to_equal {nil, nil, 3}

  - context as an object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l, 1})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:index_key' was deprecated"
        end
        _, err = capture (f, {l, 1})
        expect (err).to_be (nil)

    - it makes a map of matched table field values to table list offsets:
        l = List {{a = "b", c = "d"}, {e = "x", f = "g"}, {a = "x"}}
        t = l:index_key "a"
        expect (t).to_equal {b = 1, x = 3}
        for k, v in pairs (t) do
          expect (k).to_equal (l[v]["a"])
        end
    - it captures only the last matching list offset:
        l = List {{a = "b"}, {a = "x"}, {a = "b"}}
        t = l:index_key "a"
        expect (t.b).not_to_be (1)
        expect (t.x).to_be (2)
        expect (t.b).to_be (3)
    - it produces incomplete indices when faced with repeated matching table values:
        l = List {{1, 2, 3}, {2}, {2, 1, 3, 2, 1}}
        expect (l:index_key (1)).to_equal {1, 3}
        expect (l:index_key (2)).to_equal {3, 1}
        expect (l:index_key (3)).to_equal {nil, nil, 3}


- describe index_value:
  - before:
      fname = "index_value"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {1, List {{1}}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list.index_value' was deprecated"
        end
        _, err = capture (f, {1, List {{1}}})
        expect (err).to_be (nil)

    - it makes a table of matched table field values to table list references:
        l = List {{a = "b", c = "d"}, {e = "x", f = "g"}, {a = "x"}}
        t = f ("a", l)
        expect (t).to_equal {b = l[1], x = l[3]}
        for k, v in pairs (t) do
          expect (k).to_equal (v["a"])
        end
    - it captures only the last matching list offset:
        l = List {{a = "b"}, {a = "x"}, {a = "b"}}
        t = f ("a", l)
        expect (t.b).not_to_be (l[1])
        expect (t.x).to_be (l[2])
        expect (t.b).to_be (l[3])
    - it produces incomplete indices when faced with repeated matching table values:
        l = List {{1, 2, 3}, {2}, {2, 1, 3, 2, 1}}
        expect (f (1, l)).to_equal {l[1], l[3]}
        expect (f (2, l)).to_equal {l[3], l[1]}
        expect (f (3, l)).to_equal {nil, nil, l[3]}

  - context as an object method:
    - before:
        l = List {{1}}
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l, 1})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:index_value' was deprecated"
        end
        _, err = capture (f, {l, 1})
        expect (err).to_be (nil)

    - it makes a table of matched table field values to table list references:
        l = List {{a = "b", c = "d"}, {e = "x", f = "g"}, {a = "x"}}
        t = l:index_value "a"
        expect (t).to_equal {b = l[1], x = l[3]}
        for k, v in pairs (t) do
          expect (k).to_equal (v["a"])
        end
    - it captures only the last matching list offset:
        l = List {{a = "b"}, {a = "x"}, {a = "b"}}
        t = l:index_value "a"
        expect (t.b).not_to_be (l[1])
        expect (t.x).to_be (l[2])
        expect (t.b).to_be (l[3])
    - it produces incomplete indices when faced with repeated matching table values:
        l = List {{1, 2, 3}, {2}, {2, 1, 3, 2, 1}}
        expect (l:index_value (1)).to_equal {l[1], l[3]}
        expect (l:index_value (2)).to_equal {l[3], l[1]}
        expect (l:index_value (3)).to_equal {nil, nil, l[3]}


- describe map:
  - before:
      l = List {1, 2, 3, 4, 5}
      sq = function (n) return n * n end

      fname = "map"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
      expect (f (sq)).to_error (msg (2, "List or table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (f (sq, false)).to_error (msg (2, "List or table", "boolean"))
  - it diagnoses too many arguments:
      expect (f (sq, l, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - context when called as a list object method:
    - it returns a list object:
        m = l:map (sq)
        expect (prototype (m)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:map (sq)).to_equal (List {})
    - it creates a new list:
        o = l
        m = l:map (sq)
        expect (l).to_equal (o)
        expect (m).not_to_equal (o)
        expect (l).to_equal (List {1, 2, 3, 4, 5})
    - it maps a function over a list:
        expect (l:map (sq)).to_equal (List {1, 4, 9, 16, 25})


- describe map_with:
  - before:
      l = List {List {1, 2, 3}, List {4, 5}}
      fn = function (...) return select ("#", ...) end

      fname = "map_with"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {fn, l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list.map_with' was deprecated"
        end
        _, err = capture (f, {fn, l})
        expect (err).to_be (nil)

    - it returns a list object:
        m = f (fn, l)
        expect (prototype (m)).to_be "List"
    - it creates a new list:
        o = l
        m = f (fn, l)
        expect (l).to_equal (o)
        expect (m).not_to_equal (o)
        expect (l).to_equal (List {List {1, 2, 3}, List {4, 5}})
    - it maps a function over a list:
        expect (f (fn, l)).to_equal (List {3, 2})
    - it works for an empty list:
        l = List {}
        expect (f (fn, l)).to_equal (List {})

  - context when called as a list object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l, fn})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:map_with' was deprecated"
        end
        _, err = capture (f, {l, fn})
        expect (err).to_be (nil)

    - it returns a list object:
        m = f (l, fn)
        expect (prototype (m)).to_be "List"
    - it creates a new list:
        o = l
        m = f (l, fn)
        expect (l).to_equal (o)
        expect (m).not_to_equal (o)
        expect (l).to_equal (List {List {1, 2, 3}, List {4, 5}})
    - it maps a function over a list:
        expect (f (l, fn)).to_equal (List {3, 2})
    - it works for an empty list:
        l = List {}
        expect (f (l, fn)).to_equal (List {})


- describe project:
  - before:
      l = List {
        {first = false, second = true, third = true},
        {first = 1, second = 2, third = 3},
        {first = "1st", second = "2nd", third = "3rd"},
      }

      fname = "project"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "any value"))
      expect (f (f)).to_error (msg (2, "List"))
  - it diagnoses wrong argument types:
      expect (f (f, false)).to_error (msg (2, "List", "boolean"))
      expect (f (f, List {false})).
        to_error (msg (2, "List of tables", "boolean at index 1"))
      expect (f (f, List {{}, false})).
        to_error (msg (2, "List of tables", "boolean at index 2"))
  - it diagnoses too many arguments:
      expect (f (f, l, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - context when called as a list object method:
    - it returns a list object:
        p = l:project ("third")
        expect (prototype (p)).to_be "List"
    - it works with an empty list:
        l = List {}
        expect (l:project ("third")).to_equal (List {})
    - it projects a list of fields from a list of tables:
        expect (l:project ("third")).
          to_equal (List {true, 3, "3rd"})
    - it projects fields with a falsey value correctly:
        expect (l:project ("first")).
          to_equal (List {false, 1, "1st"})


- describe relems:
  - before:
      fname = "relems"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {{}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list.relems' was deprecated"
        end
        _, err = capture (f, {{}})
        expect (err).to_be (nil)

    - it is a reverse iterator over list members:
        t = {}
        for e in f (l) do table.insert (t, e) end
        expect (t).to_equal {"baz", "bar", "foo"}
    - it works for an empty list:
        t = {}
        for e in f (List {}) do table.insert (t, e) end
        expect (t).to_equal {}

  - context as an object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:relems' was deprecated"
        end
        _, err = capture (f, {l})
        expect (err).to_be (nil)

    - it is a reverse iterator over list members:
        t = {}
        for e in l:relems () do table.insert (t, e) end
        expect (t).to_equal {"baz", "bar", "foo"}
    - it works for an empty list:
        t, l = {}, List {}
        for e in l:relems () do table.insert (t, e) end
        expect (t).to_equal {}



- describe rep:
  - before:
      l = List {"foo", "bar"}

      fname = "rep"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "List"))
      expect (f (l)).to_error (msg (2, "int"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "List", "boolean"))
      expect (f (l, false)).to_error (msg (2, "int", "boolean"))
  - it diagnoses too many arguments:
      expect (f (l, 2, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - context when called as a list object method:
    - it returns a list object:
        expect (prototype (l:rep (3))).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:rep (99)).to_equal (List {})
    - it repeats the contents of a list:
        expect (l:rep (3)).
          to_equal (List {"foo", "bar", "foo", "bar", "foo", "bar"})


- describe reverse:
  - before:
      l = List {"foo", "bar", "baz", "quux"}

      fname = "reverse"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {{}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list.reverse' was deprecated"
        end
        _, err = capture (f, {{}})
        expect (err).to_be (nil)

    - it returns a list object:
        expect (prototype (f (l))).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (f (l)).to_equal (List {})
    - it makes a new reversed list:
        m = l
        expect (f (l)).
          to_equal (List {"quux", "baz", "bar", "foo"})
        expect (l).to_equal (List {"foo", "bar", "baz", "quux"})
        expect (l).to_be (m)

  - context when called as a list object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:reverse' was deprecated"
        end
        _, err = capture (f, {l})
        expect (err).to_be (nil)

    - it returns a list object:
        expect (prototype (l:reverse ())).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:reverse ()).to_equal (List {})
    - it makes a new reversed list:
        m = l
        expect (l:reverse ()).
          to_equal (List {"quux", "baz", "bar", "foo"})
        expect (l).to_equal (List {"foo", "bar", "baz", "quux"})
        expect (l).to_be (m)


- describe shape:
  - before:
      l = List {1, 2, 3, 4, 5, 6}

      fname = "shape"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
      expect (f ({})).to_error (msg (2, "List"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
      expect (f ({}, false)).to_error (msg (2, "List", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, l, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - context when called as a list object method:
    - it returns a list object: |
        expect (prototype (l:shape {2, 3})).to_be "List"
    - it returns the result in a new list object: |
        expect (l:shape {2, 3}):not_to_be (l)
    - it does not perturb the argument list: |
        m = l:shape {2, 3}
        expect (l).to_equal (List {1, 2, 3, 4, 5, 6})
    - it reshapes a list according to given dimensions: |
        expect (l:shape {2, 3}).
          to_equal (List {List {1, 2, 3}, List {4, 5, 6}})
        expect (l:shape {3, 2}).
          to_equal (List {List {1, 2}, List {3, 4}, List {5, 6}})
    - it treats 0-valued dimensions as an indefinite number:
        expect (l:shape {2, 0}).
          to_equal (List {List {1, 2, 3}, List {4, 5, 6}})
        expect (l:shape {0, 2}).
          to_equal (List {List {1, 2}, List {3, 4}, List {5, 6}})
    - it works for an empty list: |
        l = List {}
        expect (l:shape {0}).to_equal (List {})


- describe sub:
  - before:
      l = List {1, 2, 3, 4, 5, 6, 7}

      fname = "sub"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "List"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "List", "boolean"))
      expect (f (l, false)).to_error (msg (2, "int or nil", "boolean"))
      expect (f (l, 1, false)).to_error (msg (3, "int or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f (l, 1, 2, false)).
        to_error (toomanyarg (this_module, fname, 3, 4))

  - context when called as a list object method:
    - it returns a list object: |
        expect (prototype (l:sub (1, 1))).to_be "List"
    - it makes a list from a subrange of another list: |
        expect (l:sub (2, 5)).to_equal (List {2, 3, 4, 5})
    - it truncates the result if 'to' argument is too large: |
        expect (l:sub (5, 10)).to_equal (List {5, 6, 7})
    - it defaults 'to' to the end of the list: |
        expect (l:sub (5)).to_equal (List {5, 6, 7})
    - it defaults 'from' to the beginning of the list: |
        expect (l:sub ()).to_equal (l)
    - it returns an empty list when 'from' is greater than 'to': |
        expect (l:sub (2, 1)).to_equal (List {})
    - it counts from the end of the list for a negative 'from' argument: |
        expect (l:sub (-3)).to_equal (List {5, 6, 7})
    - it counts from the end of the list for a negative 'to' argument: |
        expect (l:sub (-5, -2)).to_equal (List {3, 4, 5, 6})


- describe tail:
  - before:
      l = List {1, 2, 3, 4, 5, 6, 7}

      fname = "tail"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "List"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "List", "boolean"))
  - it diagnoses too many arguments:
      expect (f (l, false)).
        to_error (toomanyarg (this_module, fname, 1, 2))

  - context when called as a list object method:
    - it returns a list object: |
        expect (prototype (l:tail ())).to_be "List"
    - it makes a new list with the first element removed: |
        expect (l:tail ()).to_equal (List {2, 3, 4, 5, 6, 7})
    - it works for an empty list: |
        l = List {}
        expect (l:tail ()).to_equal (List {})
    - it returns an empty list when passed a list with one element: |
        l = List {1}
        expect (l:tail ()).to_equal (List {})


- describe transpose:
  - before:
      l = List {List {1, 2}, List {3, 4}, List {5, 6}}
      fname = "transpose"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it diagnoses missing arguments:
        expect (f ()).to_error (msg (1, "List"))
    - it diagnoses wrong argument types:
        expect (f (false)).to_error (msg (1, "List", "boolean"))
    - it diagnoses too many arguments:
        expect (f (l, false)).
          to_error (toomanyarg (this_module, fname, 1, 2))

    - it transposes rows and columns:
        expect (f (l)).to_equal (List {List {1, 3, 5}, List {2, 4, 6}})
    - it works for an empty list:
        expect (f (List {})).to_equal (List {})

  - context as a list object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:transpose' was deprecated"
        end
        _, err = capture (f, {l})
        expect (err).to_be (nil)

    - it returns a list object: |
        expect (prototype (l:transpose ())).to_be "List"
    - it returns the result in a new list object: |
        expect (l:transpose ()):not_to_be (l)
    - it does not perturb the argument list: |
        m = l:transpose ()
        expect (l).to_equal (List {List {1, 2}, List {3, 4}, List {5, 6}})
    - it performs a matrix transpose operation: |
        expect (l:transpose ()).
          to_equal (List {List {1, 3, 5}, List {2, 4, 6}})
    - it works for an empty list: |
        l = List {}
        expect (l:transpose ()).to_equal (List {})


- describe zip_with:
  - before:
      l = List {List {1, 2}, List {3, 4}, List {5}}
      fn = function (...) return tonumber (table.concat {...}) end

      fname = "zip_with"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it diagnoses missing arguments:
        expect (f ()).to_error (msg (1, "List"))
        expect (f (l)).to_error (msg (2, "function"))
    - it diagnoses wrong argument types:
        expect (f (false)).to_error (msg (1, "List", "boolean"))
        expect (f (List {{}}, f)).
          to_error (msg (1, "List of Lists", "empty table at index 1"))
        expect (f (List {List {}, false}, f)).
          to_error (msg (1, "List of Lists", "boolean at index 2"))
        expect (f (l, false)).to_error (msg (2, "function", "boolean"))
    - it diagnoses too many arguments:
        expect (f (l, fn, false)).
          to_error (toomanyarg (this_module, fname, 2, 3))

    - it returns a list object:
        expect (prototype (f (l, fn))).to_be "List"
    - it returns the result in a new list object:
        expect (f (l, fn)):not_to_be (l)
    - it does not perturb the argument list:
        m = f (l, fn)
        expect (l).to_equal (List {List {1, 2}, List {3, 4}, List {5}})
    - it combines column entries with a function:
        expect (f (l, fn)).to_equal (List {135, 24})
    - it works for an empty list:
        l = List {}
        expect (f (l, fn)).to_equal (List {})

  - context as a list object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l, fn})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'std.list:zip_with' was deprecated"
        end
        _, err = capture (f, {l, fn})
        expect (err).to_be (nil)

    - it returns a list object: |
        expect (prototype (f (l, fn))).to_be "List"
    - it returns the result in a new list object: |
        expect (f (l, fn)):not_to_be (l)
    - it does not perturb the argument list: |
        m = f (l, fn)
        expect (l).to_equal (List {List {1, 2}, List {3, 4}, List {5}})
    - it combines column entries with a function: |
        expect (f (l, fn)).to_equal (List {135, 24})
    - it works for an empty list: |
        l = List {}
        expect (f (l, fn)).to_equal (List {})
