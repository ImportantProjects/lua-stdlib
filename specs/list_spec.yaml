before:
  this_module = "std.list"

  M = require (this_module)

  List    = M {}
  l       = List {"foo", "bar", "baz"}


specify std.list:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to="_G", by="std.list"}).
          to_equal {}

- describe construction:
  - context from List clone method:
    - it constructs a new list:
        l = List:clone {}
        expect (l).not_to_be (List)
        expect (prototype (l)).to_be "List"
    - it reuses the List metatable:
        l, m = List:clone {"l"}, List:clone {"m"}
        expect (getmetatable (l)).to_be (getmetatable (m))
    - it initialises List with constructor parameters:
        m = List:clone {"foo", "bar", "baz"}
        expect (m).to_equal (l)
    - it serves as a prototype for new instances:
        m = l:clone {}
        expect (prototype (m)).to_be "List"
        expect (m).to_equal (l)
        expect (getmetatable (m)).to_be (getmetatable (l))

  # List {args} is just syntactic sugar for List:clone {args}
  - context from List object prototype:
    - it constructs a new list:
        l = List {}
        expect (l).not_to_be (List)
        expect (prototype (l)).to_be "List"
    - it reuses the List metatable:
        l, m = List {"l"}, List {"m"}
        expect (getmetatable (l)).to_be (getmetatable (m))
    - it initialises list with constructor parameters:
        m = List {"foo", "bar", "baz"}
        expect (m).to_equal (l)
    - it serves as a prototype for new instances:
        m = l {}
        expect (prototype (m)).to_be "List"
        expect (m).to_equal (l)
        expect (getmetatable (m)).to_be (getmetatable (l))


- describe metatable propagation:
  - it reuses the metatable for List constructed objects:
      m = List {"foo", "bar"}
      expect (getmetatable (m)).to_be (getmetatable (l))


- describe append:
  - before:
      f = M.append
  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.append' (List expected, got no value)"
      expect (f (l)).
        to_error "bad argument #2 to 'std.list.append' (any value expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.append' (List expected, got boolean)"
  - context when called as a list object method:
    - it returns a list object:
        l = l:append ("quux")
        expect (prototype (l)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:append ("quux")).to_equal (List {"quux"})
    - it appends an item to a list:
        expect (l:append ("quux")).
          to_equal (List {"foo", "bar", "baz", "quux"})
  - context when called as a list metamethod:
    - it returns a list object:
        l = l + "quux"
        expect (prototype (l)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l + "quux").to_equal (List {"quux"})
    - it appends an item to a list:
        expect (l + "quux").
          to_equal (List {"foo", "bar", "baz", "quux"})


- describe compare:
  - before:
      a, b = List {"foo", "bar"}, List {"foo", "baz"}
      f = M.compare
  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.compare' (List expected, got no value)"
      expect (f (l)).
        to_error "bad argument #2 to 'std.list.compare' (List or table expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.compare' (List expected, got boolean)"
      expect (f (a, false)).
        to_error "bad argument #2 to 'std.list.compare' (List or table expected, got boolean)"
  - context when called as a list object method:
    - it returns -1 when the first list is less than the second: |
        expect (a:compare {"foo", "baz"}).to_be (-1)
        expect (a:compare (List {"foo", "baz"})).to_be (-1)
    - it returns -1 when the second list has additional elements: |
        b = List {"foo"}
        expect (b:compare {"foo", "bar"}).to_be (-1)
        expect (List {"foo"}:compare (List {"foo", "bar"})).to_be (-1)
    - it returns 0 when two lists are the same: |
        expect (a:compare {"foo", "bar"}).to_be (0)
        expect (a:compare (List {"foo", "bar"})).to_be (0)
    - it returns +1 when the first list is greater than the second: |
        expect (a:compare {"baz", "quux"}).to_be (1)
        expect (a:compare (List {"baz", "quux"})).to_be (1)
    - it returns +1 when the first list has additional elements: |
        expect (a:compare {"foo"}).to_be (1)
        expect (a:compare (List {"foo"})).to_be (1)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a:compare (b)).to_be (-1)
  - context when called as a '<' list metamethod:
    - it succeeds when the first list is less than the second:
        expect (a < b).to_be (true)
    - it fails when the first list is not less than the second:
        expect (a < a).to_be (false)
        expect (b < a).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a < b).to_be (true)
  - context when called as a '>' list metamethod:
    - it succeeds when the first list is greater than the second:
        expect (b > a).to_be (true)
    - it fails when the first list is not greater than the second:
        expect (b > b).to_be (false)
        expect (a > b).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a > b).to_be (false)
  - context when called as a '<=' list metamethod:
    - it succeeds when the first list is less than or equal to the second:
        expect (a <= b).to_be (true)
        expect (a <= a).to_be (true)
    - it fails when the first list is not less than or equal to the second:
        expect (b <= a).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a <= b).to_be (true)
  - context when called as a '>=' list metamethod:
    - it succeeds when the first list is greater than or equal to the second:
        expect (b >= a).to_be (true)
        expect (b >= b).to_be (true)
    - it fails when the first list is not greater than or equal to the second:
        expect (a >= b).to_be (false)
    - it compares numerically when both arguments can be coerced:
        a, b = List {"1", "2", "3"}, List {"1", "2", "10"}
        expect (a >= b).to_be (false)


- describe concat:
  - before:
      l = List {"foo", "bar"}
      f = M.concat
  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.concat' (List expected, got no value)"
      expect (f (l)).
        to_error "bad argument #2 to 'std.list.concat' (List or table expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.concat' (List expected, got boolean)"
      expect (f (l, false)).
        to_error "bad argument #2 to 'std.list.concat' (List or table expected, got boolean)"
      expect (f (l, l, false)).
        to_error "bad argument #3 to 'std.list.concat' (List or table expected, got boolean)"

  - context when called as a list object method:
    - it returns a list object:
        l = l:concat (List {"baz"})
        expect (prototype (l)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:concat (List {"baz"})).to_equal (List {"baz"})
    - it concatenates lists:
        expect (l:concat (List {"baz", "quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (l:concat (List {"baz"}, List {"quux"})).
          to_equal (List {"foo", "bar", "baz", "quux"})
  - context whne called as a list metamethod:
    - it returns a list object:
        l = l .. List {"baz"}
        expect (prototype (l)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l .. List {"baz"}).to_equal (List {"baz"})
    - it concatenates lists:
        expect (l .. List {"baz", "quux"}).
          to_equal (List {"foo", "bar", "baz", "quux"})
        expect (l .. List {"baz"} .. List {"quux"}).
          to_equal (List {"foo", "bar", "baz", "quux"})


- describe cons:
  - before:
      f = M.cons
  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.cons' (List expected, got no value)"
      expect (f (l)).
        to_error "bad argument #2 to 'std.list.cons' (any value expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.cons' (List expected, got boolean)"
  - context when called as a list object method:
    - it returns a list object:
        l = l:cons "quux"
        expect (prototype (l)).to_be "List"
    - it works for empty lists:
        l = List {}
        expect (l:cons "quux").to_equal (List {"quux"})
    - it prepends an item to a list:
        expect (l:cons "quux").
          to_equal (List {"quux", "foo", "bar", "baz"})


- describe depair:
  - before:
      t = {"first", "second", third = 4}
      l = M.enpair (t)

      fname = "depair"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it diagnoses missing arguments:
        expect (f ()).to_error (msg (1, "List or table"))
    - it diagnoses wrong argument types:
        expect (f (false)).to_error (msg (1, "List or table", "boolean"))
        expect (f (List {0})).
          to_error (msg (1, "List or table of pairs", "number at index 1"))
        expect (f (List {{}})).
          to_error (msg (1, "List or table of pairs", "0-tuple at index 1"))
        expect (f (List {{"a"}})).
          to_error (msg (1, "List or table of pairs", "1-tuple at index 1"))
        expect (f (List {{"a", "b"}, ""})).
          to_error (msg (1, "List or table of pairs", "string at index 2"))

    - it returns a primitive table:
        expect (prototype (f (l))).to_be "table"
    - it works with an empty list:
        l = List {}
        expect (f (l)).to_equal {}
    - it is the inverse of enpair:
        expect (f (l)).to_equal (t)

  - context as a list object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list:depair' was deprecated"
        end
        expect (select (2, capture (f, {l}))).to_be (nil)

    - it returns a primitive table:
        expect (prototype (l:depair ())).to_be "table"
    - it works with an empty list:
        l = List {}
        expect (l:depair ()).to_equal {}
    - it is the inverse of enpair:
        expect (l:depair ()).to_equal (t)


- describe elems:
  - before:
      fname = "elems"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {{}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list.elems' was deprecated"
        end
        expect (select (2, capture (f, {{}}))).to_be (nil)

    - it is an iterator over list members:
        t = {}
        for e in f (l) do table.insert (t, e) end
        expect (t).to_equal {"foo", "bar", "baz"}
    - it works for an empty list:
        t = {}
        for e in f (List {}) do table.insert (t, e) end
        expect (t).to_equal {}

  - context as an object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list:elems' was deprecated"
        end
        _, err = capture (f, {l})
        expect (err).to_be (nil)

    - it is an iterator over list members:
        t = {}
        for e in l:elems () do table.insert (t, e) end
        expect (t).to_equal {"foo", "bar", "baz"}
    - it works for an empty list:
        t, l = {}, List {}
        for e in l:elems () do table.insert (t, e) end
        expect (t).to_equal {}


- describe enpair:
  - before:
     t = {"first", "second", third = 4}

     fname = "enpair"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it diagnoses missing arguments:
        expect (f ()).to_error (msg (1, "table"))
    - it diagnoses wrong argument types: |
        expect (f (false)).to_error (msg (1, "table", "boolean"))

    - it returns a list object:
        expect (prototype (f (t))).to_be "List"
    - it works for an empty table:
        expect (f {}).to_equal (List {})
    - it turns a table into a list of pairs:
        expect (f (t)).
          to_equal (List {List {1, "first"}, List {2, "second"}, List {"third", 4}})


- describe filter:
  - before:
      l = List {"foo", "bar", "baz", "quux"}
      p = function (e) return (e:match "a" ~= nil) end
      f = M.filter

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.filter' (function expected, got no value)"
      expect (f (f)).
        to_error "bad argument #2 to 'std.list.filter' (List expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.filter' (function expected, got boolean)"
      expect (f (f, false)).
        to_error "bad argument #2 to 'std.list.filter' (List expected, got boolean)"

  - context when called as a list object method:
    - it returns a list object:
        m = l:filter (p)
        expect (prototype (m)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:filter (p)).to_equal (List {})
    - it filters a list according to a predicate:
        expect (l:filter (p)).to_equal (List {"bar", "baz"})


- describe flatten:
  - before:
      l = List {List {List {"one"}}, "two", List {List {"three"}, "four"}}
      f = M.flatten

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.flatten' (List expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.flatten' (List expected, got boolean)"

  - context when called as a list object method:
    - it returns a list object:
        m = List.flatten (l)
        expect (prototype (m)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:flatten ()).to_equal (List {})
    - it flattens a list:
        expect (l:flatten ()).
          to_equal (List {"one", "two", "three", "four"})


- describe foldl:
  - before:
      op = require "std.functional".op
      l = List {1, 10, 100}
      f = M.foldl

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.foldl' (function expected, got no value)"
      expect (f (f, nil)).
        to_error "bad argument #3 to 'std.list.foldl' (List expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.foldl' (function expected, got boolean)"
      expect (f (f, nil, false)).
        to_error "bad argument #3 to 'std.list.foldl' (List expected, got boolean)"

  - context when called as a list object method:
    - it works with an empty list:
        l = List {}
        expect (l:foldl (op["+"], 10000)).to_be (10000)
    - it folds a binary function through a list:
        expect (l:foldl (op["+"], 10000)).to_be (10111)


- describe foldr:
  - before:
      op = require "std.functional".op
      l = List {1, 10, 100}
      f = M.foldr

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.foldr' (function expected, got no value)"
      expect (f (f, nil)).
        to_error "bad argument #3 to 'std.list.foldr' (List expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.foldr' (function expected, got boolean)"
      expect (f (f, nil, false)).
        to_error "bad argument #3 to 'std.list.foldr' (List expected, got boolean)"

  - context when called as a list object method:
    - it works with an empty list:
        l = List {}
        expect (l:foldl (op["/"], 1)).to_be (1)
    - it folds a binary function through a list:
        expect (l:foldl (op["/"], 10000)).to_be (10)


- describe index_key:
  - before:
      fname = "index_key"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {1, List {{1}}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list.index_key' was deprecated"
        end
        _, err = capture (f, {1, List {{1}}})
        expect (err).to_be (nil)

    - it makes a map of matched table field values to table list offsets:
        l = List {{a = "b", c = "d"}, {e = "x", f = "g"}, {a = "x"}}
        t = f ("a", l)
        expect (t).to_equal {b = 1, x = 3}
        for k, v in pairs (t) do
          expect (k).to_equal (l[v]["a"])
        end
    - it captures only the last matching list offset:
        l = List {{a = "b"}, {a = "x"}, {a = "b"}}
        t = f ("a", l)
        expect (t.b).not_to_be (1)
        expect (t.x).to_be (2)
        expect (t.b).to_be (3)
    - it produces incomplete indices when faced with repeated matching table values:
        l = List {{1, 2, 3}, {2}, {2, 1, 3, 2, 1}}
        expect (f (1, l)).to_equal {1, 3}
        expect (f (2, l)).to_equal {3, 1}
        expect (f (3, l)).to_equal {nil, nil, 3}

  - context as an object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l, 1})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list:index_key' was deprecated"
        end
        _, err = capture (f, {l, 1})
        expect (err).to_be (nil)

    - it makes a map of matched table field values to table list offsets:
        l = List {{a = "b", c = "d"}, {e = "x", f = "g"}, {a = "x"}}
        t = l:index_key "a"
        expect (t).to_equal {b = 1, x = 3}
        for k, v in pairs (t) do
          expect (k).to_equal (l[v]["a"])
        end
    - it captures only the last matching list offset:
        l = List {{a = "b"}, {a = "x"}, {a = "b"}}
        t = l:index_key "a"
        expect (t.b).not_to_be (1)
        expect (t.x).to_be (2)
        expect (t.b).to_be (3)
    - it produces incomplete indices when faced with repeated matching table values:
        l = List {{1, 2, 3}, {2}, {2, 1, 3, 2, 1}}
        expect (l:index_key (1)).to_equal {1, 3}
        expect (l:index_key (2)).to_equal {3, 1}
        expect (l:index_key (3)).to_equal {nil, nil, 3}


- describe index_value:
  - before:
      fname = "index_value"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {1, List {{1}}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list.index_value' was deprecated"
        end
        _, err = capture (f, {1, List {{1}}})
        expect (err).to_be (nil)

    - it makes a table of matched table field values to table list references:
        l = List {{a = "b", c = "d"}, {e = "x", f = "g"}, {a = "x"}}
        t = f ("a", l)
        expect (t).to_equal {b = l[1], x = l[3]}
        for k, v in pairs (t) do
          expect (k).to_equal (v["a"])
        end
    - it captures only the last matching list offset:
        l = List {{a = "b"}, {a = "x"}, {a = "b"}}
        t = f ("a", l)
        expect (t.b).not_to_be (l[1])
        expect (t.x).to_be (l[2])
        expect (t.b).to_be (l[3])
    - it produces incomplete indices when faced with repeated matching table values:
        l = List {{1, 2, 3}, {2}, {2, 1, 3, 2, 1}}
        expect (f (1, l)).to_equal {l[1], l[3]}
        expect (f (2, l)).to_equal {l[3], l[1]}
        expect (f (3, l)).to_equal {nil, nil, l[3]}

  - context as an object method:
    - before:
        l = List {{1}}
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l, 1})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list:index_value' was deprecated"
        end
        _, err = capture (f, {l, 1})
        expect (err).to_be (nil)

    - it makes a table of matched table field values to table list references:
        l = List {{a = "b", c = "d"}, {e = "x", f = "g"}, {a = "x"}}
        t = l:index_value "a"
        expect (t).to_equal {b = l[1], x = l[3]}
        for k, v in pairs (t) do
          expect (k).to_equal (v["a"])
        end
    - it captures only the last matching list offset:
        l = List {{a = "b"}, {a = "x"}, {a = "b"}}
        t = l:index_value "a"
        expect (t.b).not_to_be (l[1])
        expect (t.x).to_be (l[2])
        expect (t.b).to_be (l[3])
    - it produces incomplete indices when faced with repeated matching table values:
        l = List {{1, 2, 3}, {2}, {2, 1, 3, 2, 1}}
        expect (l:index_value (1)).to_equal {l[1], l[3]}
        expect (l:index_value (2)).to_equal {l[3], l[1]}
        expect (l:index_value (3)).to_equal {nil, nil, l[3]}


- describe map:
  - before:
      l = List {1, 2, 3, 4, 5}
      sq = function (n) return n * n end
      f = M.map

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.map' (function expected, got no value)"
      expect (f (f)).
        to_error "bad argument #2 to 'std.list.map' (List or table expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.map' (function expected, got boolean)"
      expect (f (f, false)).
        to_error "bad argument #2 to 'std.list.map' (List or table expected, got boolean)"

  - context when called as a list object method:
    - it returns a list object:
        m = l:map (sq)
        expect (prototype (m)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:map (sq)).to_equal (List {})
    - it creates a new list:
        o = l
        m = l:map (sq)
        expect (l).to_equal (o)
        expect (m).not_to_equal (o)
        expect (l).to_equal (List {1, 2, 3, 4, 5})
    - it maps a function over a list:
        expect (l:map (sq)).to_equal (List {1, 4, 9, 16, 25})


- describe map_with:
  - before:
      l = List {List {1, 2, 3}, List {4, 5}}
      n = function (...) return select ("#", ...) end
      f = M.map_with

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.map_with' (function expected, got no value)"
      expect (f (f)).
        to_error "bad argument #2 to 'std.list.map_with' (List expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.map_with' (function expected, got boolean)"
      expect (f (f, false)).
        to_error "bad argument #2 to 'std.list.map_with' (List expected, got boolean)"
      expect (f (f, List {{}})).
        to_error "bad argument #2 to 'std.list.map_with' (List of Lists expected, got table at index 1)"
      expect (f (f, List {List {}, false})).
        to_error "bad argument #2 to 'std.list.map_with' (List of Lists expected, got boolean at index 2)"

  - context when called as a list object method:
    - it returns a list object:
        m = l:map_with (n)
        expect (prototype (m)).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:map_with (n)).to_equal (List {})
    - it creates a new list:
        o = l
        m = l:map_with (n)
        expect (l).to_equal (o)
        expect (m).not_to_equal (o)
        expect (l).to_equal (List {List {1, 2, 3}, List {4, 5}})
    - it maps a function over a list:
        expect (l:map_with (n)).to_equal (List {3, 2})


- describe project:
  - before:
      l = List {
        {first = false, second = true, third = true},
        {first = 1, second = 2, third = 3},
        {first = "1st", second = "2nd", third = "3rd"},
      }
      f = M.project

  - it diagnoses missing arguments: |
      expect (f (f)).
        to_error "bad argument #2 to 'std.list.project' (List expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (f, false)).
        to_error "bad argument #2 to 'std.list.project' (List expected, got boolean)"
      expect (f (f, List {false})).
        to_error "bad argument #2 to 'std.list.project' (List of tables expected, got boolean at index 1)"
      expect (f (f, List {{}, false})).
        to_error "bad argument #2 to 'std.list.project' (List of tables expected, got boolean at index 2)"

  - context when called as a list object method:
    - it returns a list object:
        p = l:project ("third")
        expect (prototype (p)).to_be "List"
    - it works with an empty list:
        l = List {}
        expect (l:project ("third")).to_equal (List {})
    - it projects a list of fields from a list of tables:
        expect (l:project ("third")).
          to_equal (List {true, 3, "3rd"})
    - it projects fields with a falsey value correctly:
        expect (l:project ("first")).
          to_equal (List {false, 1, "1st"})


- describe relems:
  - before:
      fname = "relems"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {{}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list.relems' was deprecated"
        end
        _, err = capture (f, {{}})
        expect (err).to_be (nil)

    - it is a reverse iterator over list members:
        t = {}
        for e in f (l) do table.insert (t, e) end
        expect (t).to_equal {"baz", "bar", "foo"}
    - it works for an empty list:
        t = {}
        for e in f (List {}) do table.insert (t, e) end
        expect (t).to_equal {}

  - context as an object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list:relems' was deprecated"
        end
        _, err = capture (f, {l})
        expect (err).to_be (nil)

    - it is a reverse iterator over list members:
        t = {}
        for e in l:relems () do table.insert (t, e) end
        expect (t).to_equal {"baz", "bar", "foo"}
    - it works for an empty list:
        t, l = {}, List {}
        for e in l:relems () do table.insert (t, e) end
        expect (t).to_equal {}



- describe rep:
  - before:
      l = List {"foo", "bar"}
      f = M.rep

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.rep' (List expected, got no value)"
      expect (f (l)).
        to_error "bad argument #2 to 'std.list.rep' (int expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.rep' (List expected, got boolean)"
      expect (f (l, false)).
        to_error "bad argument #2 to 'std.list.rep' (int expected, got boolean)"

  - context when called as a list object method:
    - it returns a list object:
        expect (prototype (l:rep (3))).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:rep (99)).to_equal (List {})
    - it repeats the contents of a list:
        expect (l:rep (3)).
          to_equal (List {"foo", "bar", "foo", "bar", "foo", "bar"})


- describe reverse:
  - before:
      l = List {"foo", "bar", "baz", "quux"}

      fname = "reverse"

  - context as a module function:
    - before:
        f = M[fname]

    - it writes a deprecation warning to standard error on first call: |
        -- Unwrap functable
        f = type (f) == "function" and f or f.call or (getmetatable (f) or {}).__call

        _, err = capture (f, {{}})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list.reverse' was deprecated"
        end
        _, err = capture (f, {{}})
        expect (err).to_be (nil)

    - it returns a list object:
        expect (prototype (f (l))).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (f (l)).to_equal (List {})
    - it makes a new reversed list:
        m = l
        expect (f (l)).
          to_equal (List {"quux", "baz", "bar", "foo"})
        expect (l).to_equal (List {"foo", "bar", "baz", "quux"})
        expect (l).to_be (m)

  - context when called as a list object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list:reverse' was deprecated"
        end
        _, err = capture (f, {l})
        expect (err).to_be (nil)

    - it returns a list object:
        expect (prototype (l:reverse ())).to_be "List"
    - it works for an empty list:
        l = List {}
        expect (l:reverse ()).to_equal (List {})
    - it makes a new reversed list:
        m = l
        expect (l:reverse ()).
          to_equal (List {"quux", "baz", "bar", "foo"})
        expect (l).to_equal (List {"foo", "bar", "baz", "quux"})
        expect (l).to_be (m)


- describe shape:
  - before:
      l = List {1, 2, 3, 4, 5, 6}
      f = M.shape

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.shape' (table expected, got no value)"
      expect (f ({})).
        to_error "bad argument #2 to 'std.list.shape' (List expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.shape' (table expected, got boolean)"
      expect (f ({}, false)).
        to_error "bad argument #2 to 'std.list.shape' (List expected, got boolean)"

  - context when called as a list object method:
    - it returns a list object: |
        expect (prototype (l:shape {2, 3})).to_be "List"
    - it returns the result in a new list object: |
        expect (l:shape {2, 3}):not_to_be (l)
    - it does not perturb the argument list: |
        m = l:shape {2, 3}
        expect (l).to_equal (List {1, 2, 3, 4, 5, 6})
    - it reshapes a list according to given dimensions: |
        expect (l:shape {2, 3}).
          to_equal (List {List {1, 2, 3}, List {4, 5, 6}})
        expect (l:shape {3, 2}).
          to_equal (List {List {1, 2}, List {3, 4}, List {5, 6}})
    - it treats 0-valued dimensions as an indefinite number:
        expect (l:shape {2, 0}).
          to_equal (List {List {1, 2, 3}, List {4, 5, 6}})
        expect (l:shape {0, 2}).
          to_equal (List {List {1, 2}, List {3, 4}, List {5, 6}})
    - it works for an empty list: |
        l = List {}
        expect (l:shape {0}).to_equal (List {})


- describe sub:
  - before:
      l = List {1, 2, 3, 4, 5, 6, 7}
      f = M.sub

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.sub' (List expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.sub' (List expected, got boolean)"
      expect (f (l, false)).
        to_error "bad argument #2 to 'std.list.sub' (int or nil expected, got boolean)"
      expect (f (l, 1, false)).
        to_error "bad argument #3 to 'std.list.sub' (int or nil expected, got boolean)"

  - context when called as a list object method:
    - it returns a list object: |
        expect (prototype (l:sub (1, 1))).to_be "List"
    - it makes a list from a subrange of another list: |
        expect (l:sub (2, 5)).to_equal (List {2, 3, 4, 5})
    - it truncates the result if 'to' argument is too large: |
        expect (l:sub (5, 10)).to_equal (List {5, 6, 7})
    - it defaults 'to' to the end of the list: |
        expect (l:sub (5)).to_equal (List {5, 6, 7})
    - it defaults 'from' to the beginning of the list: |
        expect (l:sub ()).to_equal (l)
    - it returns an empty list when 'from' is greater than 'to': |
        expect (l:sub (2, 1)).to_equal (List {})
    - it counts from the end of the list for a negative 'from' argument: |
        expect (l:sub (-3)).to_equal (List {5, 6, 7})
    - it counts from the end of the list for a negative 'to' argument: |
        expect (l:sub (-5, -2)).to_equal (List {3, 4, 5, 6})


- describe tail:
  - before:
      l = List {1, 2, 3, 4, 5, 6, 7}
      f = M.tail

  - it diagnoses missing arguments: |
      expect (f ()).
        to_error "bad argument #1 to 'std.list.tail' (List expected, got no value)"
  - it diagnoses wrong argument types: |
      expect (f (false)).
        to_error "bad argument #1 to 'std.list.tail' (List expected, got boolean)"

  - context when called as a list object method:
    - it returns a list object: |
        expect (prototype (l:tail ())).to_be "List"
    - it makes a new list with the first element removed: |
        expect (l:tail ()).to_equal (List {2, 3, 4, 5, 6, 7})
    - it works for an empty list: |
        l = List {}
        expect (l:tail ()).to_equal (List {})
    - it returns an empty list when passed a list with one element: |
        l = List {1}
        expect (l:tail ()).to_equal (List {})


- describe transpose:
  - before:
      l = List {List {1, 2}, List {3, 4}, List {5, 6}}
      fname = "transpose"

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it diagnoses missing arguments:
        expect (f ()).to_error (msg (1, "table or List"))
    - it diagnoses wrong argument types: |
        expect (f (false)).to_error (msg (1, "table or List", "boolean"))

    - it transposes rows and columns:
        expect (f (l)).to_equal (List {List {1, 3, 5}, List {2, 4, 6}})
    - it works for an empty list:
        expect (f (List {})).to_equal (List {})

  - context as a list object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list:transpose' was deprecated"
        end
        _, err = capture (f, {l})
        expect (err).to_be (nil)

    - it returns a list object: |
        expect (prototype (l:transpose ())).to_be "List"
    - it returns the result in a new list object: |
        expect (l:transpose ()):not_to_be (l)
    - it does not perturb the argument list: |
        m = l:transpose ()
        expect (l).to_equal (List {List {1, 2}, List {3, 4}, List {5, 6}})
    - it performs a matrix transpose operation: |
        expect (l:transpose ()).
          to_equal (List {List {1, 3, 5}, List {2, 4, 6}})
    - it works for an empty list: |
        l = List {}
        expect (l:transpose ()).to_equal (List {})


- describe zip_with:
  - before:
      l = List {List {1, 2}, List {3, 4}, List {5}}
      fn = function (...) return tonumber (table.concat {...}) end

      fname = "zip_with"
      f = l[fname]

  - context as a module function:
    - before:
        msg = bind (badarg, {this_module, fname})
        f = M[fname]

    - it diagnoses missing arguments: |
        expect (f ()).to_error (msg (1, "List"))
        expect (f (l)).to_error (msg (2, "function"))
    - it diagnoses wrong argument types: |
        expect (f (false)).to_error (msg (1, "List", "boolean"))
        expect (f (List {{}}, f)).
          to_error (msg (1, "List of Lists", "table at index 1"))
        expect (f (List {List {}, false}, f)).
          to_error (msg (1, "List of Lists", "boolean at index 2"))
        expect (f (l, false)).to_error (msg (2, "function", "boolean"))

    - it returns a list object: |
        expect (prototype (f (l, fn))).to_be "List"
    - it returns the result in a new list object: |
        expect (f (l, fn)):not_to_be (l)
    - it does not perturb the argument list: |
        m = f (l, fn)
        expect (l).to_equal (List {List {1, 2}, List {3, 4}, List {5}})
    - it combines column entries with a function: |
        expect (f (l, fn)).to_equal (List {135, 24})
    - it works for an empty list: |
        l = List {}
        expect (f (l, fn)).to_equal (List {})

  - context as a list object method:
    - before:
        f = l[fname]

    - it writes a deprecation warning to standard error on first call: |
        _, err = capture (f, {l, fn})
        if err ~= nil then
          -- skip this test when using Specl < 12 capture stub
          expect (err).to_contain "'list:zip_with' was deprecated"
        end
        _, err = capture (f, {l, fn})
        expect (err).to_be (nil)

    - it returns a list object: |
        expect (prototype (f (l, fn))).to_be "List"
    - it returns the result in a new list object: |
        expect (f (l, fn)):not_to_be (l)
    - it does not perturb the argument list: |
        m = f (l, fn)
        expect (l).to_equal (List {List {1, 2}, List {3, 4}, List {5}})
    - it combines column entries with a function: |
        expect (f (l, fn)).to_equal (List {135, 24})
    - it works for an empty list: |
        l = List {}
        expect (f (l, fn)).to_equal (List {})
