before: |
  base_module  = "debug"
  this_module  = "std.debug"
  global_table = "_G"

  extend_base  = { "argcheck", "argerror", "argscheck", "say", "trace" }

  M = require "std.debug"

specify std.debug:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}
    - it does not touch the core debug table:
        expect (show_apis {added_to=base_module, by=this_module}).
          to_equal {}
    - it contains apis from the core debug table:
        expect (show_apis {from=base_module, not_in=this_module}).
          to_contain.a_permutation_of (extend_base)

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}
    - it does not touch the core debug table:
        expect (show_apis {added_to=base_module, by="std"}).
          to_equal {}


- describe argerror:
  - before: |
      function mkstack (level)
        return string.format ([[
          _DEBUG = true                           -- line 1
          local debug = require "std.debug"       -- line 2
          function ohnoes ()                      -- line 3
            debug.argerror ("ohnoes", 1, nil, %s) -- line 4
          end                                     -- line 5
          function caller ()                      -- line 6
            local r = ohnoes ()                   -- line 7
            return "not a tail call"              -- line 8
          end                                     -- line 9
          caller ()                               -- line 10
        ]], tostring (level))
      end

      f, badarg = init (M, this_module,  "argerror")

  - it diagnoses missing arguments:
      pending "Lua 5.1 support is dropped"
      expect (f ()).to_raise (badarg (1, "string"))
      expect (f "foo").to_raise (badarg (2, "int"))
  - it diagnoses wrong argument types:
      pending "Lua 5.1 support is dropped"
      expect (f (false)).to_raise (badarg (1, "string", "boolean"))
      expect (f ("foo", false)).to_raise (badarg (2, "int", "boolean"))
      expect (f ("foo", 1, false)).
        to_raise (badarg (3, "string or nil", "boolean"))
      expect (f ("foo", 1, "bar", false)).
        to_raise (badarg (4, "int or nil", "boolean"))
  - it diagnoses too many arguments:
      pending "Lua 5.1 support is dropped"
      expect (f ("foo", 1, "bar", 2, false)).to_raise (badarg (5))

  - it blames the call site by default: |
      expect (luaproc (mkstack ())).to_contain_error ":4: bad argument"
  - it honors optional call stack level reporting: |
      expect (luaproc (mkstack (1))).to_contain_error ":4: bad argument"
      expect (luaproc (mkstack (2))).to_contain_error ":7: bad argument"
  - it reports the calling function name:
      expect (f ('expect', 1)).to_raise "'expect'"
  - it reports the argument number: |
      expect (f ('expect', 12345)).to_raise "#12345"
  - it reports extra message in parentheses:
      expect (f ('expect', 1, "extramsg")).to_raise " (extramsg)"


- describe argcheck:
  - before: |
      Object = require 'std.object'
      List = require "std.list"
      Foo = Object { _type = "Foo" }

      function fn (...) return M.argcheck ('expect', 1, ...) end

      function mkstack (level, debugp)
        return string.format ([[
          _DEBUG = %s                                    -- line 1
          local debug = require "std.debug"              -- line 2
          function ohnoes (t)                            -- line 3
            debug.argcheck ("ohnoes", 1, "table", t, %s) -- line 4
          end                                            -- line 5
          function caller ()                             -- line 6
            local r = ohnoes "not a table"               -- line 7
            return "not a tail call"                     -- line 8
          end                                            -- line 9
          caller ()                                      -- line 10
        ]], tostring (debugp), tostring (level))
      end

      f, badarg = init (M, this_module,  "argcheck")

  - it diagnoses missing arguments:
      pending "Lua 5.1 support is dropped"
      expect (f ()).to_raise (badarg (1, "string"))
      expect (f "foo").to_raise (badarg (2, "int"))
      expect (f ("foo", 1)).to_raise (badarg (3, "string"))
  - it diagnoses wrong argument types:
      pending "Lua 5.1 support is dropped"
      expect (f (false)).to_raise (badarg (1, "string", "boolean"))
      expect (f ("foo", false)).to_raise (badarg (2, "int", "boolean"))
      expect (f ("foo", 1, false)).to_raise (badarg (3, "string", "boolean"))
      expect (f ("foo", 1, "bar", 2, false)).
        to_raise (badarg (5, "int or nil", "boolean"))
  - it diagnoses too many arguments:
      pending "Lua 5.1 support is dropped"
      expect (f ("foo", 1, "bar", 2, 3, false)).to_raise (badarg (6))

  - it blames the calling function by default: |
      expect (luaproc (mkstack ())).to_contain_error ":7: bad argument"
  - it honors optional call stack level reporting: |
      expect (luaproc (mkstack (1))).to_contain_error ":4: bad argument"
      expect (luaproc (mkstack (2))).to_contain_error ":7: bad argument"
      expect (luaproc (mkstack (3))).to_contain_error ":10: bad argument"
  - it can be disabled by setting _DEBUG to false:
      expect (luaproc (mkstack (nil, false))).
        not_to_contain_error "bad argument"
  - it can be disabled by setting _DEBUG.argcheck to false:
      expect (luaproc (mkstack (nil, "{ argcheck = false }"))).
        not_to_contain_error "bad argument"
  - it is not disabled by setting _DEBUG.argcheck to true:
      expect (luaproc (mkstack (nil, "{ argcheck = true }"))).
        to_contain_error "bad argument"
  - it is not disabled by leaving _DEBUG.argcheck unset:
      expect (luaproc (mkstack (nil, "{}"))).
        to_contain_error "bad argument"

  - context with primitives:
    - it diagnoses missing types:
        expect (fn ("boolean", nil)).to_raise "boolean expected, got no value"
        expect (fn ("file", nil)).to_raise "file expected, got no value"
        expect (fn ("number", nil)).to_raise "number expected, got no value"
        expect (fn ("string", nil)).to_raise "string expected, got no value"
        expect (fn ("table", nil)).to_raise "table expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("boolean", {0})).to_raise "boolean expected, got table"
        expect (fn ("file", {0})).to_raise "file expected, got table"
        expect (fn ("number", {0})).to_raise "number expected, got table"
        expect (fn ("string", {0})).to_raise "string expected, got table"
        expect (fn ("table", false)).to_raise "table expected, got boolean"
        expect (fn ("table", require "std.object")).
          to_raise "table expected, got Object"
    - it matches types:
        expect (fn ("boolean", true)).not_to_raise "any error"
        expect (fn ("file", io.stderr)).not_to_raise "any error"
        expect (fn ("number", 1)).not_to_raise "any error"
        expect (fn ("string", "s")).not_to_raise "any error"
        expect (fn ("table", {})).not_to_raise "any error"
  - context with int:
    - it diagnoses missing types:
        expect (fn ("int", nil)).to_raise "int expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("int", false)).to_raise "int expected, got boolean"
        expect (fn ("int", 1.234)).to_raise "int expected, got number"
        expect (fn ("int", 1234e-3)).to_raise "int expected, got number"
    - it matches types:
        expect (fn ("int", 1)).not_to_raise "any error"
        expect (fn ("int", 1.0)).not_to_raise "any error"
        expect (fn ("int", 0x1234)).not_to_raise "any error"
        expect (fn ("int", 1.234e3)).not_to_raise "any error"
  - context with constant string:
    - it diagnoses missing types:
        expect (fn (":foo", nil)).to_raise ":foo expected, got no value"
    - it diagnoses mismatched types:
        expect (fn (":foo", false)).to_raise ":foo expected, got boolean"
        expect (fn (":foo", ":bar")).to_raise ":foo expected, got :bar"
        expect (fn (":foo", "foo")).to_raise ":foo expected, got string"
    - it matches types:
        expect (fn (":foo", ":foo")).not_to_raise "any error"
  - context with callable types:
    - it diagnoses missing types:
        expect (fn ("function", nil)).to_raise "function expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("function", {0})).to_raise "function expected, got table"
    - it matches types:
        expect (fn ("function", function () end)).not_to_raise "any error"
        expect (fn ("function", setmetatable ({}, {__call = function () end}))).
          not_to_raise "any error"
  - context with table of homogenous elements:
    - it diagnoses missing types:
        expect (fn ("table of boolean", nil)).
          to_raise "table expected, got no value"
        expect (fn ("table of booleans", nil)).
          to_raise "table expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("table of file", io.stderr)).
          to_raise "table expected, got file"
        expect (fn ("table of files", io.stderr)).
          to_raise "table expected, got file"
    - it diagnoses mismatched element types:
        expect (fn ("table of number", {false})).
          to_raise "table of numbers expected, got boolean at index 1"
        expect (fn ("table of numbers", {1, 2, "3"})).
          to_raise "table of numbers expected, got string at index 3"
        expect (fn ("table of numbers", {a=1, b=2, c="3"})).
          to_raise "table of numbers expected, got string at index c"
    - it matches types:
        expect (fn ("table of string", {})).not_to_raise "any error"
        expect (fn ("table of string", {"foo"})).not_to_raise "any error"
        expect (fn ("table of string", {"f", "o", "o"})).not_to_raise "any error"
        expect (fn ("table of string", {b="b", a="a", r="r"})).not_to_raise "any error"
  - context with non-empty table types:
    - it diagnoses missing types:
        expect (fn ("#table", nil)).
          to_raise "non-empty table expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("#table", false)).
          to_raise "non-empty table expected, got boolean"
        expect (fn ("#table", {})).
          to_raise "non-empty table expected, got empty table"
    - it matches types:
        expect (fn ("#table", {0})).not_to_raise "any error"
  - context with non-empty table of homogenous elements:
    - it diagnoses missing types:
        expect (fn ("#table of boolean", nil)).
          to_raise "non-empty table expected, got no value"
        expect (fn ("#table of booleans", nil)).
          to_raise "non-empty table expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("#table of file", {})).
          to_raise "non-empty table expected, got empty table"
        expect (fn ("#table of file", io.stderr)).
          to_raise "non-empty table expected, got file"
    - it diagnoses mismatched element types:
        expect (fn ("#table of number", {false})).
          to_raise "non-empty table of numbers expected, got boolean at index 1"
        expect (fn ("#table of numbers", {1, 2, "3"})).
          to_raise "non-empty table of numbers expected, got string at index 3"
        expect (fn ("#table of numbers", {a=1, b=2, c="3"})).
          to_raise "non-empty table of numbers expected, got string at index c"
    - it matches types:
        expect (fn ("#table of string", {"foo"})).not_to_raise "any error"
        expect (fn ("#table of string", {"f", "o", "o"})).not_to_raise "any error"
        expect (fn ("#table of string", {b="b", a="a", r="r"})).not_to_raise "any error"
  - context with list:
    - it diagnonses missing types:
        expect (fn ("list", nil)).
          to_raise "list expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("list", false)).
          to_raise "list expected, got boolean"
        expect (fn ("list", {foo=1})).
          to_raise "list expected, got table"
        expect (fn ("list", Object)).
          to_raise "list expected, got Object"
    - it matches types:
        expect (fn ("list", {})).not_to_raise "any error"
        expect (fn ("list", {1})).not_to_raise "any error"
  - context with list of homogenous elements:
    - it diagnoses missing types:
        expect (fn ("list of boolean", nil)).
          to_raise "list expected, got no value"
        expect (fn ("list of booleans", nil)).
          to_raise "list expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("list of file", io.stderr)).
          to_raise "list expected, got file"
        expect (fn ("list of files", io.stderr)).
          to_raise "list expected, got file"
        expect (fn ("list of files", {file=io.stderr})).
          to_raise "list expected, got table"
    - it diagnoses mismatched element types:
        expect (fn ("list of number", {false})).
          to_raise "list of numbers expected, got boolean at index 1"
        expect (fn ("list of numbers", {1, 2, "3"})).
          to_raise "list of numbers expected, got string at index 3"
    - it matches types:
        expect (fn ("list of string", {})).not_to_raise "any error"
        expect (fn ("list of string", {"foo"})).not_to_raise "any error"
        expect (fn ("list of string", {"f", "o", "o"})).not_to_raise "any error"
  - context with non-empty list:
    - it diagnonses missing types:
        expect (fn ("#list", nil)).
          to_raise "non-empty list expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("#list", false)).
          to_raise "non-empty list expected, got boolean"
        expect (fn ("#list", {})).
          to_raise "non-empty list expected, got empty list"
        expect (fn ("#list", {foo=1})).
          to_raise "non-empty list expected, got table"
        expect (fn ("#list", Object)).
          to_raise "non-empty list expected, got empty Object"
        expect (fn ("#list", List {})).
          to_raise "non-empty list expected, got empty List"
    - it matches types:
        expect (fn ("#list", {1})).not_to_raise "any error"
  - context with non-empty list of homogenous elements:
    - it diagnoses missing types:
        expect (fn ("#list of boolean", nil)).
          to_raise "non-empty list expected, got no value"
        expect (fn ("#list of booleans", nil)).
          to_raise "non-empty list expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("#list of file", {})).
          to_raise "non-empty list expected, got empty table"
        expect (fn ("#list of file", io.stderr)).
          to_raise "non-empty list expected, got file"
        expect (fn ("#list of files", {file=io.stderr})).
          to_raise "non-empty list expected, got table"
    - it diagnoses mismatched element types:
        expect (fn ("#list of number", {false})).
          to_raise "non-empty list of numbers expected, got boolean at index 1"
        expect (fn ("#list of numbers", {1, 2, "3"})).
          to_raise "non-empty list of numbers expected, got string at index 3"
    - it matches types:
        expect (fn ("#list of string", {"foo"})).not_to_raise "any error"
        expect (fn ("#list of string", {"f", "o", "o"})).not_to_raise "any error"
  - context with container:
    - it diagnoses missing types:
        expect (fn ("List of boolean", nil)).
          to_raise "List expected, got no value"
        expect (fn ("List of booleans", nil)).
          to_raise "List expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("List of file", io.stderr)).
          to_raise "List expected, got file"
        expect (fn ("List of files", io.stderr)).
          to_raise "List expected, got file"
        expect (fn ("List of files", {file=io.stderr})).
          to_raise "List expected, got table"
    - it diagnoses mismatched element types:
        expect (fn ("List of number", List {false})).
          to_raise "List of numbers expected, got boolean at index 1"
        expect (fn ("List of numbers", List {1, 2, "3"})).
          to_raise "List of numbers expected, got string at index 3"
    - it matches types:
        expect (fn ("list of string", List {})).not_to_raise "any error"
        expect (fn ("list of string", List {"foo"})).not_to_raise "any error"
        expect (fn ("list of string", List {"f", "o", "o"})).not_to_raise "any error"
  - context with object:
    - it diagnoses missing types:
        expect (fn ("object", nil)).to_raise "object expected, got no value"
        expect (fn ("Object", nil)).to_raise "Object expected, got no value"
        expect (fn ("Foo", nil)).to_raise "Foo expected, got no value"
        expect (fn ("any", nil)).to_raise "any value expected, got no value"
    - it diagnoses mismatched types:
        expect (fn ("object", {0})).to_raise "object expected, got table"
        expect (fn ("Object", {0})).to_raise "Object expected, got table"
        expect (fn ("object", {_type="Object"})).to_raise "object expected, got table"
        expect (fn ("Object", {_type="Object"})).to_raise "Object expected, got table"
        expect (fn ("Object", Foo)).to_raise "Object expected, got Foo"
        expect (fn ("Foo", {0})).to_raise "Foo expected, got table"
        expect (fn ("Foo", Object)).to_raise "Foo expected, got Object"
    - it matches types:
        expect (fn ("object", Object)).not_to_raise "any error"
        expect (fn ("object", Object {})).not_to_raise "any error"
        expect (fn ("object", Foo)).not_to_raise "any error"
        expect (fn ("object", Foo {})).not_to_raise "any error"
  - it matches anything:
      expect (fn ("any", true)).not_to_raise "any error"
      expect (fn ("any", {})).not_to_raise "any error"
      expect (fn ("any", Object)).not_to_raise "any error"
      expect (fn ("any", Foo {})).not_to_raise "any error"
  - context with a list of valid types:
    - it diagnoses missing elements:
        expect (fn ("string|table", nil)).
          to_raise "string or table expected, got no value"
        expect (fn ("string|list|#table", nil)).
          to_raise "string, list or non-empty table expected, got no value"
        expect (fn ("string|number|list|object", nil)).
          to_raise "string, number, list or object expected, got no value"
    - it diagnoses mismatched elements:
        expect (fn ("string|table", false)).
          to_raise "string or table expected, got boolean"
        expect (fn ("string|#table", {})).
          to_raise "string or non-empty table expected, got empty table"
        expect (fn ("string|number|#list|object", {})).
          to_raise "string, number, non-empty list or object expected, got empty table"
    - it matches any type from a list:
        expect (fn ("string|table", "foo")).not_to_raise "any error"
        expect (fn ("string|table", {})).not_to_raise "any error"
        expect (fn ("string|table", {0})).not_to_raise "any error"
        expect (fn ("table|table", {})).not_to_raise "any error"
        expect (fn ("#table|table", {})).not_to_raise "any error"
  - context with an optional type element:
    - it diagnoses mismatched elements:
        expect (fn ("boolean?", "string")).
          to_raise "boolean or nil expected, got string"
        expect (fn ("boolean?|:symbol", {})).
          to_raise "boolean, :symbol or nil expected, got empty table"
    - it matches nil against a single type:
        expect (fn ("any?", nil)).not_to_raise "any error"
        expect (fn ("boolean?", nil)).not_to_raise "any error"
        expect (fn ("string?", nil)).not_to_raise "any error"
    - it matches nil against a list of types:
        expect (fn ("boolean?|table", nil)).not_to_raise "any error"
        expect (fn ("string?|table", nil)).not_to_raise "any error"
        expect (fn ("table?|#table", nil)).not_to_raise "any error"
        expect (fn ("#table?|table", nil)).not_to_raise "any error"
    - it matches nil against a list of optional types:
        expect (fn ("boolean?|table?", nil)).not_to_raise "any error"
        expect (fn ("string?|table?", nil)).not_to_raise "any error"
        expect (fn ("table?|#table?", nil)).not_to_raise "any error"
        expect (fn ("#table?|table?", nil)).not_to_raise "any error"
    - it matches any named type:
        expect (fn ("any?", false)).not_to_raise "any error"
        expect (fn ("boolean?", false)).not_to_raise "any error"
        expect (fn ("string?", "string")).not_to_raise "any error"
    - it matches any type from a list:
        expect (fn ("boolean?|table", {})).not_to_raise "any error"
        expect (fn ("string?|table", {0})).not_to_raise "any error"
        expect (fn ("table?|#table", {})).not_to_raise "any error"
        expect (fn ("#table?|table", {})).not_to_raise "any error"
    - it matches any type from a list with several optional specifiers:
        expect (fn ("boolean?|table?", {})).not_to_raise "any error"
        expect (fn ("string?|table?", {0})).not_to_raise "any error"
        expect (fn ("table?|table?", {})).not_to_raise "any error"
        expect (fn ("#table?|table?", {})).not_to_raise "any error"


- describe argscheck:
  - before: |
      function fn (...) return M.argscheck ('expect', ...) end

      function mkstack (debugp)
        return string.format ([[
          _DEBUG = %s                                               -- line 1
          local debug = require "std.debug"                         -- line 2
          function ohnoes (t, n)                                    -- line 3
            debug.argscheck ("ohnoes", {"table", "number"}, {t, n}) -- line 4
          end                                                       -- line 5
          function caller ()                                        -- line 6
            local r = ohnoes ({}, "not a number")                   -- line 7
            return "not a tail call"                                -- line 8
          end                                                       -- line 9
          caller ()                                                 -- line 10
        ]], tostring (debugp))
      end

      f, badarg = init (M, this_module,  "argscheck")

  - it diagnoses missing arguments:
      pending "Lua 5.1 support is dropped"
      expect (f "foo").to_raise (badarg (2, "non-empty list"))
      expect (f ("foo", {"bar"})).to_raise (badarg (3, "table"))
  - it diagnoses wrong argument types:
      pending "Lua 5.1 support is dropped"
      expect (f (false)).to_raise (badarg (1, "string", "boolean"))
      expect (f ("foo", false)).
        to_raise (badarg (2, "non-empty list", "boolean"))
      expect (f ("foo", {"bar"}, false)).to_raise (badarg (3, "table", "boolean"))
  - it diagnoses too many arguments:
      pending "Lua 5.1 support is dropped"
      expect (f ("foo", {"bar"}, {}, false)).to_raise (badarg (4))

  - it blames the calling function: |
      expect (luaproc (mkstack ())).to_contain_error ":7: bad argument"
  - it can be disabled by setting _DEBUG to false:
      expect (luaproc (mkstack (false))).
        not_to_contain_error "bad argument"
  - it can be disabled by setting _DEBUG.argcheck to false:
      expect (luaproc (mkstack ("{ argcheck = false }"))).
        not_to_contain_error "bad argument"
  - it is not disabled by setting _DEBUG.argcheck to true:
      expect (luaproc (mkstack ("{ argcheck = true }"))).
        to_contain_error "bad argument"
  - it is not disabled by leaving _DEBUG.argcheck unset:
      expect (luaproc (mkstack ("{}"))).
        to_contain_error "bad argument"
  - context with single argument table:
    - it diagnoses missing argument:
        expect (fn ({"boolean"}, {nil})).
          to_raise "boolean expected, got no value"
    - it reports the correct missing argument number:
        expect (fn ({"boolean"}, {nil})).to_raise "#1 "
    - it diagnoses mismatched argument:
        expect (fn ({"boolean"}, {"false"})).
          to_raise "boolean expected, got string"
    - it reports the correct mismatched argument number:
        expect (fn ({"boolean"}, {"false"})).to_raise "#1 "
    - it matches argument type:
        expect (fn ({"boolean"}, {false})).not_to_raise "any error"
  - context with multi-argument table:
    - it diagnoses missing argument:
        expect (fn ({"boolean", "table"}, {false, nil})).
          to_raise "table expected, got no value"
        expect (fn ({"boolean", "table", "string"}, {false, nil, "nil"})).
          to_raise "table expected, got no value"
    - it reports the correct missing argument number:
        expect (fn ({"boolean", "table"}, {false, nil})).to_raise "#2 "
        expect (fn ({"boolean", "table", "string"}, {false, nil, "nil"})).
          to_raise "#2 "
    - it diagnoses mismatched argument:
        expect (fn ({"boolean", "table"}, {false, "false"})).
          to_raise "table expected, got string"
        expect (fn ({"boolean", "table", "string"}, {false, "nil", "nil"})).
          to_raise "table expected, got string"
    - it reports the correct mismatched argument number:
        expect (fn ({"boolean", "table"}, {false, "false"})).to_raise "#2 "
        expect (fn ({"boolean", "table", "string"}, {false, "nil", "nil"})).
          to_raise "#2 "
    - it matches argument type:
        expect (fn ({"boolean", "table"}, {false, {}})).not_to_raise "any error"
        expect (fn ({"boolean", "table", "string"}, {false, {}, "{}"})).
          not_to_raise "any error"


- describe debug:
  - before: |
      function mkwrap (k, v)
        local fmt = "%s"
        if type (v) == "string" then fmt = "%q" end
        return k, string.format (fmt, require "std".tostring (v))
      end

      function mkdebug (debugp, ...)
        return string.format ([[
          _DEBUG = %s
          require "std.debug" (%s)
        ]],
        require "std".tostring (debugp),
        table.concat (require "std.functional".map (mkwrap, {...}), ", "))
      end

  - it does nothing when _DEBUG is disabled:
      expect (luaproc (mkdebug (false, "nothing to see here"))).
        not_to_contain_error "nothing to see here"
  - it writes to stderr when _DEBUG is not set:
      expect (luaproc (mkdebug (nil, "debugging"))).
        to_contain_error "debugging"
  - it writes to stderr when _DEBUG is enabled:
      expect (luaproc (mkdebug (true, "debugging"))).
        to_contain_error "debugging"
  - it writes to stderr when _DEBUG.level is not set:
      expect (luaproc (mkdebug ({}, "debugging"))).
        to_contain_error "debugging"
  - it writes to stderr when _DEBUG.level is specified:
      expect (luaproc (mkdebug ({level = 0}, "debugging"))).
        to_contain_error "debugging"
      expect (luaproc (mkdebug ({level = 1}, "debugging"))).
        to_contain_error "debugging"
      expect (luaproc (mkdebug ({level = 2}, "debugging"))).
        to_contain_error "debugging"


- describe say:
  - before: |
      function mkwrap (k, v)
        local fmt = "%s"
        if type (v) == "string" then fmt = "%q" end
        return k, string.format (fmt, require "std".tostring (v))
      end

      function mksay (debugp, ...)
        return string.format ([[
          _DEBUG = %s
          require "std.debug".say (%s)
        ]],
        require "std".tostring (debugp),
        table.concat (require "std.functional".map (mkwrap, {...}), ", "))
      end

      f = M.say

  - it uses stdlib tostring:
      expect (luaproc [[require "std.debug".say {"debugging"}]]).
        to_contain_error (require "std".tostring {"debugging"})
  - context when _DEBUG is disabled:
    - it does nothing when message level is not set:
        expect (luaproc (mksay (false, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
    - it does nothing when message is set:
        expect (luaproc (mksay (false, -999, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
        expect (luaproc (mksay (false, 0, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
        expect (luaproc (mksay (false, 1, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
        expect (luaproc (mksay (false, 2, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
        expect (luaproc (mksay (false, 999, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
  - context when _DEBUG is not set:
    - it writes to stderr when message level is not set:
        expect (luaproc (mksay (nil, "debugging"))).
          to_contain_error "debugging"
    - it writes to stderr when message level is 1 or lower:
        expect (luaproc (mksay (nil, -999, "debugging"))).
          to_contain_error "debugging"
        expect (luaproc (mksay (nil, 0, "debugging"))).
          to_contain_error "debugging"
        expect (luaproc (mksay (nil, 1, "debugging"))).
          to_contain_error "debugging"
    - it does nothing when message level is 2 or higher:
        expect (luaproc (mksay (nil, 2, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
        expect (luaproc (mksay (nil, 999, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
  - context when _DEBUG is enabled:
    - it writes to stderr when message level is not set:
        expect (luaproc (mksay (true, "debugging"))).
          to_contain_error "debugging"
    - it writes to stderr when message level is 1 or lower:
        expect (luaproc (mksay (true, -999, "debugging"))).
          to_contain_error "debugging"
        expect (luaproc (mksay (true, 0, "debugging"))).
          to_contain_error "debugging"
        expect (luaproc (mksay (true, 1, "debugging"))).
          to_contain_error "debugging"
    - it does nothing when message level is 2 or higher:
        expect (luaproc (mksay (true, 2, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
        expect (luaproc (mksay (true, 999, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
  - context when _DEBUG.level is not set:
    - it writes to stderr when message level is not set:
        expect (luaproc (mksay ({}, "debugging"))).
          to_contain_error "debugging"
    - it writes to stderr when message level is 1 or lower:
        expect (luaproc (mksay ({}, -999, "debugging"))).
          to_contain_error "debugging"
        expect (luaproc (mksay ({}, 0, "debugging"))).
          to_contain_error "debugging"
        expect (luaproc (mksay ({}, 1, "debugging"))).
          to_contain_error "debugging"
    - it does nothing when message level is 2 or higher:
        expect (luaproc (mksay ({}, 2, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
        expect (luaproc (mksay ({}, 999, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
  - context when _DEBUG.level is specified:
    - it writes to stderr when message level is 1 or lower:
        expect (luaproc (mksay ({level = 0}, "debugging"))).
          to_contain_error "debugging"
        expect (luaproc (mksay ({level = 1}, "debugging"))).
          to_contain_error "debugging"
        expect (luaproc (mksay ({level = 2}, "debugging"))).
          to_contain_error "debugging"
    - it does nothing when message level is higher than debug level:
        expect (luaproc (mksay ({level = 2}, 3, "nothing to see here"))).
          not_to_contain_error "nothing to see here"
    - it writes to stderr when message level equals debug level:
        expect (luaproc (mksay ({level = 2}, 2, "debugging"))).
          to_contain_error "debugging"
    - it writes to stderr when message level is lower than debug level:
        expect (luaproc (mksay ({level = 2}, 1, "debugging"))).
          to_contain_error "debugging"


- describe trace:
  - before:
      f = init (M, this_module,  "trace")

  - it does nothing when _DEBUG is disabled:
      expect (luaproc [[
        _DEBUG = false
        require "std.debug"
        os.exit (0)
      ]]).to_succeed_with ""
  - it does nothing when _DEBUG is not set:
      expect (luaproc [[
        require "std.debug"
        os.exit (0)
      ]]).to_succeed_with ""
  - it does nothing when _DEBUG is enabled:
      expect (luaproc [[
        _DEBUG = true
        require "std.debug"
        os.exit (0)
      ]]).to_succeed_with ""
  - it enables automatically when _DEBUG.call is set: |
      expect (luaproc [[
        _DEBUG = {call = true}
        local debug = require "std.debug"
        os.exit (1)
      ]]).to_fail_while_containing ":3 call exit"
  - it is enabled manually with debug.sethook: |
      expect (luaproc [[
        local debug = require "std.debug"
        debug.sethook (debug.trace, "cr")
        os.exit (1)
      ]]).to_fail_while_containing ":3 call exit"
  - it writes call trace log to standard error: |
      expect (luaproc [[
        local debug = require "std.debug"
        debug.sethook (debug.trace, "cr")
        os.exit (0)
      ]]).to_contain_error ":3 call exit"
  - it traces lua calls: |
      expect (luaproc [[
        local debug = require "std.debug"         -- line 1
        local function incr (i) return i + 1 end  -- line 2
        debug.sethook (debug.trace, "cr")         -- line 3
        os.exit (incr (41))                       -- line 4
      ]]).to_fail_while_matching ".*:4 call incr <2:.*:4 return incr <2:.*"
  - it traces C api calls: |
      expect (luaproc [[
        local debug = require "std.debug"
        local function incr (i) return i + 1 end
        debug.sethook (debug.trace, "cr")
        os.exit (incr (41))
      ]]).to_fail_while_matching ".*:4 call exit %[C%]%s$"
