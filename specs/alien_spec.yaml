before: |
  Object = require "std.object"
  prototype = Object.prototype

## ================================================================== ##
## FIXME: When anchors and aliases work, the alien and std.alien      ##
##        specifications should use an alias to prevent repetition.   ##
##        In the mean time, please be careful to make changes twice   ##
##        (once in each section) to ensure the std.alien API behaves  ##
##        identically to the real alien module!                       ##
## ================================================================== ##

specify alien:
- before: |
    -- Don't crash for a lack of an installed alien module
    have_alien, alien  = pcall (require, "alien")
    if not have_alien then
      alien = require "std.alien"
    end
- describe array:
  - before:
      fn = alien.array
  - it diagnoses missing arguments:
      expect (fn ()).to_error ()
      expect (fn "int").to_error ()
  - when initialised with a length:
    - before: |
        a = fn ("char", 4)
        for i = 1, a.length do
          a[i] = i * i
        end
        function set (i, v) a[i] = v end
    - it instantiates a new array object:
        expect (prototype (a)).
          to_be.any_of {"table", "std.alien.array"}
    - it knows its own length:
        expect (a.length).to_be (4)
    - it diagnoses out of bounds access:
        expect (a[-1]).to_error "array access out of bounds"
        expect (a[0]).to_error "array access out of bounds"
        expect (a[a.length + 1]).to_error "array access out of bounds"
        expect (a[a.length * 2]).to_error "array access out of bounds"
    - it reports value of elements by index:
        expect (a[1]).to_be (1)
        expect (a[2]).to_be (4)
        expect (a[3]).to_be (9)
        expect (a[4]).to_be (16)
    - it diagnoses out of bounds assignment:
        expect (set (-1, 42)).to_error "array access out of bounds"
        expect (set (0,  42)).to_error "array access out of bounds"
        expect (set (a.length + 1, 42)).to_error "array access out of bounds"
        expect (set (a.length * 2, 42)).to_error "array access out of bounds"
    - it allows setting of element values by index:
        expect (set (1, 42)).not_to_error ()
        expect (a[1]).to_be (42)
    - it knows the size of its elements:
        expect (a.size).to_be (1)
    - it knows the type of its elements:
        expect (a.type).to_be "char"
  - when initialised with elements:
    - before: |
        a = fn ("char", {1, 4, 9, 16})
        function set (i, v) a[i] = v end
    - it instatiates a new array object:
        expect (prototype (a)).
          to_be.any_of {"table", "std.alien.array"}
    - it knows its own length:
        expect (a.length).to_be (4)
    - it diagnoses out of bounds access:
        expect (a[-1]).to_error "array access out of bounds"
        expect (a[0]).to_error "array access out of bounds"
        expect (a[a.length + 1]).to_error "array access out of bounds"
        expect (a[a.length * 2]).to_error "array access out of bounds"
    - it reports value of elements by index:
        expect (a[1]).to_be (1)
        expect (a[2]).to_be (4)
        expect (a[3]).to_be (9)
        expect (a[4]).to_be (16)
    - it diagnoses out of bounds assignment:
        expect (set (-1, 42)).to_error "array access out of bounds"
        expect (set (0,  42)).to_error "array access out of bounds"
        expect (set (a.length + 1, 42)).to_error "array access out of bounds"
        expect (set (a.length * 2, 42)).to_error "array access out of bounds"
    - it allows setting of element values by index:
        expect (set (1, 42)).not_to_error ()
        expect (a[1]).to_be (42)
    - it knows the size of its elements:
        expect (a.size).to_be (1)
    - it knows the type of its elements:
        expect (a.type).to_be "char"

- describe memmove:
  - before:
      fn = alien.memmove
      a = alien.array ("int", 8)
      b = alien.array ("int", {1, 1, 2, 3, 5, 8, 13, 21, 34, 55})
  - it copies elements from one array to another:
      fn (a.buffer:topointer (1), b.buffer:topointer (2 * b.size + 1), 8 * a.size)
      for i = 1, a.length do
        expect (a[i]).to_be (b[i + 2])
      end
  - it shifts elements of overlapping blocks to the left:
      fn (b.buffer:topointer (1), b.buffer:topointer (2 * b.size + 1), 8 * a.size)
      for i, v in ipairs {2, 3, 5, 8, 13, 21, 34, 55, 34, 55} do
        expect (b[i]).to_be (v)
      end
  - it shifts elements of overlapping blocks to the right:
      b[1] = 0
      fn (b.buffer:topointer (2 * b.size + 1), b.buffer:topointer (1), 8 * b.size)
      for i, v in ipairs {0, 1, 0, 1, 2, 3, 5, 8, 13, 21 } do
        expect (b[i]).to_be (v)
      end

- describe memset:
  - before:
      fn = alien.memset
  - it sets a block of elements to zero:
      a = alien.array ("int", {1, 1, 2, 3, 5, 8, 13, 21, 34, 55})
      fn (a.buffer:topointer (2 * a.size + 1), 0, 6 * a.size)
      for i, v in ipairs {1, 1, 0, 0, 0, 0, 0, 0, 34, 55} do
        expect (a[i]).to_be (v)
      end

specify std.alien:
- before:
    alien  = require "std.alien"
- describe array:
  - before:
      fn = alien.array
  - it diagnoses missing arguments:
      expect (fn ()).to_error ()
      expect (fn "int").to_error ()
  - when initialised with a length:
    - before: |
        a = fn ("char", 4)
        for i = 1, a.length do
          a[i] = i * i
        end
        function set (i, v) a[i] = v end
    - it instantiates a new array object:
        expect (prototype (a)).
          to_be.any_of {"table", "std.alien.array"}
    - it knows its own length:
        expect (a.length).to_be (4)
    - it diagnoses out of bounds access:
        expect (a[-1]).to_error "array access out of bounds"
        expect (a[0]).to_error "array access out of bounds"
        expect (a[a.length + 1]).to_error "array access out of bounds"
        expect (a[a.length * 2]).to_error "array access out of bounds"
    - it reports value of elements by index:
        expect (a[1]).to_be (1)
        expect (a[2]).to_be (4)
        expect (a[3]).to_be (9)
        expect (a[4]).to_be (16)
    - it diagnoses out of bounds assignment:
        expect (set (-1, 42)).to_error "array access out of bounds"
        expect (set (0,  42)).to_error "array access out of bounds"
        expect (set (a.length + 1, 42)).to_error "array access out of bounds"
        expect (set (a.length * 2, 42)).to_error "array access out of bounds"
    - it allows setting of element values by index:
        expect (set (1, 42)).not_to_error ()
        expect (a[1]).to_be (42)
    - it knows the size of its elements:
        expect (a.size).to_be (1)
    - it knows the type of its elements:
        expect (a.type).to_be "char"
  - when initialised with elements:
    - before: |
        a = fn ("char", {1, 4, 9, 16})
        function set (i, v) a[i] = v end
    - it instatiates a new array object:
        expect (prototype (a)).
          to_be.any_of {"table", "std.alien.array"}
    - it knows its own length:
        expect (a.length).to_be (4)
    - it diagnoses out of bounds access:
        expect (a[-1]).to_error "array access out of bounds"
        expect (a[0]).to_error "array access out of bounds"
        expect (a[a.length + 1]).to_error "array access out of bounds"
        expect (a[a.length * 2]).to_error "array access out of bounds"
    - it reports value of elements by index:
        expect (a[1]).to_be (1)
        expect (a[2]).to_be (4)
        expect (a[3]).to_be (9)
        expect (a[4]).to_be (16)
    - it diagnoses out of bounds assignment:
        expect (set (-1, 42)).to_error "array access out of bounds"
        expect (set (0,  42)).to_error "array access out of bounds"
        expect (set (a.length + 1, 42)).to_error "array access out of bounds"
        expect (set (a.length * 2, 42)).to_error "array access out of bounds"
    - it allows setting of element values by index:
        expect (set (1, 42)).not_to_error ()
        expect (a[1]).to_be (42)
    - it knows the size of its elements:
        expect (a.size).to_be (1)
    - it knows the type of its elements:
        expect (a.type).to_be "char"

- describe memmove:
  - before:
      fn = alien.memmove
      a = alien.array ("int", 8)
      b = alien.array ("int", {1, 1, 2, 3, 5, 8, 13, 21, 34, 55})
  - it copies elements from one array to another:
      fn (a.buffer:topointer (1), b.buffer:topointer (2 * b.size + 1), 8 * a.size)
      for i = 1, a.length do
        expect (a[i]).to_be (b[i + 2])
      end
  - it shifts elements of overlapping blocks to the left:
      fn (b.buffer:topointer (1), b.buffer:topointer (2 * b.size + 1), 8 * a.size)
      for i, v in ipairs {2, 3, 5, 8, 13, 21, 34, 55, 34, 55} do
        expect (b[i]).to_be (v)
      end
  - it shifts elements of overlapping blocks to the right:
      b[1] = 0
      fn (b.buffer:topointer (2 * b.size + 1), b.buffer:topointer (1), 8 * b.size)
      for i, v in ipairs {0, 1, 0, 1, 2, 3, 5, 8, 13, 21 } do
        expect (b[i]).to_be (v)
      end

- describe memset:
  - before:
      fn = alien.memset
  - it sets a block of elements to zero:
      a = alien.array ("int", {1, 1, 2, 3, 5, 8, 13, 21, 34, 55})
      fn (a.buffer:topointer (2 * a.size + 1), 0, 6 * a.size)
      for i, v in ipairs {1, 1, 0, 0, 0, 0, 0, 0, 34, 55} do
        expect (a[i]).to_be (v)
      end
