before: |
  this_module  = "std.lua"
  global_table = "_G"

  M = require (this_module)

specify std.lua:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}


- describe assert:
  - before:
      fname = "assert"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses wrong argument types:
      expect (f (false, false)).to_error (msg (2, "string or nil", "boolean"))

  - context when it does not trigger:
    - it has a truthy initial argument:
        expect (f (1)).not_to_error ()
        expect (f (true)).not_to_error ()
        expect (f "yes").not_to_error ()
        expect (f (false == false)).not_to_error ()
    - it returns the initial argument:
        expect (f (1)).to_be (1)
        expect (f (true)).to_be (true)
        expect (f "yes").to_be "yes"
        expect (f (false == false)).to_be (true)
  - context when it triggers:
    - it has a falsey initial argument:
        expect (f ()).to_error ()
        expect (f (false)).to_error ()
        expect (f (1 == 0)).to_error ()
    - it throws an optional error string:
        expect (f (false, "ah boo")).to_error "ah boo"
    - it plugs specifiers with string.format: |
        expect (f (nil, "%s %d: %q", "here", 42, "a string")).
          to_error (string.format ("%s %d: %q", "here", 42, "a string"))


- describe case:
  - before:
      yes     = function ()  return true end
      no      = function ()  return false end
      default = function (s) return s end
      branches = { yes = yes, no = no, default }
      fname = "case"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (2, "non-empty table"))
  - it diagnoses wrong argument types:
      expect (f ("no", false)).
        to_error (msg (2, "non-empty table", "boolean"))
  - it diagnoses too many arguments:
      expect (f (1, {2}, false)).
        to_error (toomanyarg (this_module, fname, 2, 3))

  - it matches against branch keys:
      expect (f ("yes", branches)).to_be (true)
      expect (f ("no",  branches)).to_be (false)
  - it has a default for unmatched keys:
      expect (f ("none", branches)).to_be "none"
  - it returns nil for unmatched keys with no default:
      expect (f ("none", { yes = yes, no = no })).to_be (nil)
  - it evaluates `with` exactly once:
      s = "prince"
      function acc () s = s .. "s"; return s end
      expect (f (acc (), {
        prince   = function () return "one" end,
        princes  = function () return "many" end,
        princess = function () return "one" end,
                   function () return "gibberish" end,
      })).to_be "many"


- describe elems:
  - before:
      fname = "elems"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it is an iterator over table values:
      t = {}
      for e in f {"foo", bar = "baz", 42} do
        t[#t + 1] = e
      end
      expect (t).to_contain.a_permutation_of {"foo", "baz", 42}
  - it respects __pairs metamethod: |
      x = setmetatable ({ "a string" }, {
        __pairs = function (x)
                     return function (x, n)
                       if n < #x[1] then
                         return n+1, string.sub (x[1], n+1, n+1)
                       end
                     end, x, 0
                   end
      })
      t = {}
      for v in f (x) do t[#t + 1] = v end
      expect (t).to_equal {"a", " ", "s", "t", "r", "i", "n", "g"}
  - it works for an empty list:
      t = {}
      for e in f {} do t[#t + 1] = e end
      expect (t).to_equal {}


- describe eval:
  - before:
      fname = "eval"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
  - it diagnoses too many arguments:
      expect (f ("1", false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it diagnoses invalid lua:
      # Some internal error when eval tries to call uncompilable "=" code.
      expect (f "=").to_error ()
  - it evaluates a string of lua code:
      expect (f "math.pow (2, 10)").to_be (math.pow (2, 10))


- describe ielems:
  - before:
      fname = "ielems"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "list"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "list", "boolean"))
      expect (f {foo = "bar"}).to_error (msg (1, "list", "table"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it is an iterator over integer-keyed table values:
      t = {}
      for e in f {"foo", 42} do
        t[#t + 1] = e
      end
      expect (t).to_equal {"foo", 42}
  - it respects __ipairs metamethod: |
      x = setmetatable ({ "a string" }, {
        __ipairs = function (x)
                     return function (x, n)
                       if n < #x[1] then
                         return n+1, string.sub (x[1], n+1, n+1)
                       end
                     end, x, 0
                   end
      })
      t = {}
      for v in f (x) do t[#t + 1] = v end
      expect (t).to_equal {"a", " ", "s", "t", "r", "i", "n", "g"}
  - it works for an empty list:
      t = {}
      for e in f {} do t[#t + 1] = e end
      expect (t).to_equal {}


- describe ipairs:
  - before:
      fname = "ipairs"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "list"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "list", "boolean"))
      expect (f {foo = "bar"}).to_error (msg (1, "list", "table"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it is an iterator over integer-keyed table values:
      t = {}
      for i, v in f {"foo", 42} do
        t[i] = v
      end
      expect (t).to_equal {"foo", 42}
  - it respects __ipairs metamethod: |
      x = setmetatable ({ "a string" }, {
        __ipairs = function (x)
                     return function (x, n)
                       if n < #x[1] then
                         return n+1, string.sub (x[1], n+1, n+1)
                       end
                     end, x, 0
                   end
      })
      t = {}
      for k, v in f (x) do t[k] = v end
      expect (t).to_equal {"a", " ", "s", "t", "r", "i", "n", "g"}
  - it works for an empty list:
      t = {}
      for i, v in f {} do t[i] = v end
      expect (t).to_equal {}


- describe lambda:
  - before:
      fname = "lambda"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong arguments types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
  - it diagnoses too many arguments:
      expect (f ("foo", false)).to_error (toomanyarg (this_module, fname, 1, 2))
  - it diagnoses bad lambda string:
      expect (select (2, f "foo")).to_be "invalid lambda string 'foo'"
  - it diagnoses an uncompilable expression:
      expect (select (2, f "||+")).to_be "invalid lambda string '||+'"
      expect (select (2, f "=")).to_be "invalid lambda string '='"

  - context with argument format:
    - it returns a function:
        expect (prototype (f "|x| 1+x")).to_be "function"
    - it compiles to a working Lua function:
        fn = f "||42"
        expect (fn ()).to_be (42)
    - it propagates argument values:
        fn = f "|...| {...}"
        expect (fn (1,2,3)).to_equal {1,2,3}
  - context with expression format:
    - it returns a function:
        expect (prototype (f "=1")).to_be "function"
    - it compiles to a working Lua function:
        fn = f "=42"
        expect (fn ()).to_be (42)
    - it sets auto-argument values:
        fn = f "=_1*_1"
        expect (fn (42)).to_be (1764)


- describe memoize:
  - before:
      fname = "memoize"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]
      memfn = f (function (x)
                   if x then return {x} else return nil, "bzzt" end
                 end)

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "function"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "function", "boolean"))
      expect (f (f, false)).to_error (msg (2, "function or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f (f, f, false)).to_error (toomanyarg (this_module, fname, 2, 3))

  - it propagates multiple return values:
      expect (select (2, memfn (false))).to_be "bzzt"
  - it returns the same object for the same arguments:
      t = memfn (1)
      expect (memfn (1)).to_be (t)
  - it returns a different object for different arguments:
      expect (memfn (1)).not_to_be (memfn (2))
  - it returns the same object for table valued arguments:
      t = memfn {1, 2, 3}
      expect (memfn {1, 2, 3}).to_be (t)
      t = memfn {foo = "bar", baz = "quux"}
      expect (memfn {foo = "bar", baz = "quux"}).to_be (t)
      expect (memfn {baz = "quux", foo = "bar"}).to_be (t)
  - it returns a different object for different table arguments:
      expect (memfn {1, 2, 3}).not_to_be (memfn {1, 2})
      expect (memfn {1, 2, 3}).not_to_be (memfn {3, 1, 2})
      expect (memfn {1, 2, 3}).not_to_be (memfn {1, 2, 3, 4})
  - it accepts alternative normalization function:
      normalize = function (...) return select ("#", ...) end
      memfn = f (function (x) return {x} end, normalize)
      expect (memfn "same").to_be (memfn "not same")
      expect (memfn (1, 2)).to_be (memfn (false, "x"))
      expect (memfn "one").not_to_be (memfn ("one", "two"))


- describe monkey_patch:
  - before:
      fname = "monkey_patch"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

      monkeys = { "assert", "case", "eval", "elems", "ielems", "ipairs",
                  "lambda", "memoize", "pairs", "require" }

      t  = {}
      f (t)

  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f (t, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it installs monkeys to the given namespace:
      expect (t).to_contain.a_permutation_of (monkeys)
      for _, monkey in ipairs (monkeys) do
        expect (t[monkey]).to_be (M[monkey])
      end


- describe pairs:
  - before:
      fname = "pairs"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_error (toomanyarg (this_module, fname, 1, 2))

  - it is an iterator over all table values:
      t = {}
      for k, v in f {"foo", bar = "baz", 42} do
        t[k] = v
      end
      expect (t).to_equal {"foo", bar = "baz", 42}
  - it respects __pairs metamethod: |
      x = setmetatable ({ "a string" }, {
        __pairs = function (x)
                     return function (x, n)
                       if n < #x[1] then
                         return n+1, string.sub (x[1], n+1, n+1)
                       end
                     end, x, 0
                   end
      })
      t = {}
      for k, v in f (x) do t[k] = v end
      expect (t).to_equal {"a", " ", "s", "t", "r", "i", "n", "g"}
  - it works for an empty list:
      t = {}
      for k, v in f {} do t[k] = v end
      expect (t).to_equal {}


- describe require:
  - before:
      fname = "require"
      msg = bind (badarg, {this_module, fname})
      f = M[fname]

  - it diagnoses missing arguments:
      expect (f ()).to_error (msg (1, "string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_error (msg (1, "string", "boolean"))
      expect (f ("module", false)).to_error (msg (2, "string or nil", "boolean"))
      expect (f ("module", "min", false)).
        to_error (msg (3, "string or nil", "boolean"))
      expect (f ("module", "min", "too_big", false)).
        to_error (msg (4, "string or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f ("module", "min", "too_big", "pattern", false)).
        to_error (toomanyarg (this_module, fname, 4, 5))

  - it diagnoses non-existent module:
      expect (f ("module-not-exists", "", "")).to_error "module-not-exists"
  - it diagnoses module too old:
      expect (f ("std", "9999", "9999")).to_error ()
  - it diagnoses module too new:
      expect (f ("std", "0", "0")).to_error ()
  - context when the module version is compatible:
    - it returns the module table:
        expect (f ("std", "0", "9999")).to_be (require "std")
    - it places no upper bound by default:
        expect (f ("std", "41")).to_be (require "std")
    - it places no lower bound by default:
        expect (f "std").to_be (require "std")
    - it uses _VERSION when version field is nil:
        std = require "std"
        std._VERSION, std.version = std.version, std._VERSION
        expect (f ("std", "41", "9999")).to_be (require "std")
        std._VERSION, std.version = std.version, std._VERSION
  - context with semantic versioning:
    - before:
        std = require "std"
        ver = std.version
        std.version = "1.2.3"
    - after:
        std.version = ver
    - it diagnoses module too old:
        expect (f ("std", "1.2.4")).to_error ()
        expect (f ("std", "1.3")).to_error ()
        expect (f ("std", "2.1.2")).to_error ()
        expect (f ("std", "2")).to_error ()
        expect (f ("std", "1.2.10")).to_error ()
    - it diagnoses module too new:
        expect (f ("std", nil, "1.2.2")).to_error ()
        expect (f ("std", nil, "1.1")).to_error ()
        expect (f ("std", nil, "1.1.2")).to_error ()
        expect (f ("std", nil, "1")).to_error ()
    - it returns modules with version in range:
        expect (f ("std")).to_be (std)
        expect (f ("std", "1")).to_be (std)
        expect (f ("std", "1.2.3")).to_be (std)
        expect (f ("std", nil, "2")).to_be (std)
        expect (f ("std", nil, "1.3")).to_be (std)
        expect (f ("std", nil, "1.2.10")).to_be (std)
        expect (f ("std", "1.2.3", "1.2.4")).to_be (std)
