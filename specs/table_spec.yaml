before: |
  base_module         = "table"
  this_module         = "std.table"
  global_table        = "_G"

  extend_base         = { "clone", "clone_rename", "clone_select", "depair",
                          "empty", "enpair", "flatten", "insert", "invert",
                          "keys", "len", "merge", "merge_select", "metamethod",
                          "monkey_patch", "new", "pack", "project", "ripairs",
                          "shape", "size", "sort", "totable", "values" }

  M = require "std.table"

specify std.table:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}
    - it does not touch the core table table:
        expect (show_apis {added_to=base_module, by=this_module}).
          to_equal {}
    - it contains apis from the core table table:
        expect (show_apis {from=base_module, not_in=this_module}).
          to_contain.a_permutation_of (extend_base)

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).to_equal {}
    - it does not touch the core table table:
        expect (show_apis {added_to=base_module, by="std"}).to_equal {}


- describe clone:
  - before:
      subject = { k1 = {"v1"}, k2 = {"v2"}, k3 = {"v3"} }
      withmt  = setmetatable (M.clone (subject), {"meta!"})

      f, badarg = init (M, this_module, "clone")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
      expect (f ({}, "nometa")).
        to_raise (badarg (2, "table, boolean, :nometa or nil", "string"))
      expect (f ({}, {}, "nometa")).
        to_raise (badarg (3, "boolean, :nometa or nil", "string"))
  - it diagnoses too many arguments:
      expect (f ({}, {}, nil, false)).to_raise (badarg (4))

  - it does not just return the subject:
      expect (f (subject)).not_to_be (subject)
  - it does copy the subject:
      expect (f (subject)).to_equal (subject)
  - it only makes a shallow copy of field values:
      expect (f (subject).k1).to_be (subject.k1)
  - it does not perturb the original subject:
      target = { k1 = subject.k1, k2 = subject.k2, k3 = subject.k3 }
      copy   = f (subject)
      expect (subject).to_equal (target)
      expect (subject).to_be (subject)

  - context with metatables:
    - it copies the metatable by default:
        expect (getmetatable (f (withmt))).to_be (getmetatable (withmt))
    - it treats non-table arg2 as nometa parameter:
        expect (getmetatable (f (withmt, ":nometa"))).to_be (nil)
    - it treats table arg2 as a map parameter:
        expect (getmetatable (f (withmt, {}))).to_be (getmetatable (withmt))
    - it supports 3 arguments with nometa as arg3:
        expect (getmetatable (f (withmt, {}, ":nometa"))).to_be (nil)

  - context when renaming some keys:
    - it renames during cloning:
        target = { newkey = subject.k1, k2 = subject.k2, k3 = subject.k3 }
        expect (f (subject, {k1 = "newkey"})).to_equal (target)
    - it does not perturb the value in the renamed key field:
        expect (f (subject, {k1 = "newkey"}).newkey).to_be (subject.k1)


- describe clone_rename:
  - before:
      subject = { k1 = {"v1"}, k2 = {"v2"}, k3 = {"v3"} }

      fname = "clone_rename"
      f = M[fname]

  - it writes a deprecation warning on first call:
      expect (capture (f, {{}, subject})).to_contain_error "was deprecated"
      expect (capture (f, {{}, subject})).not_to_contain_error "was deprecated"

  - it copies the subject:
      expect (f ({}, subject)).to_copy (subject)
  - it only makes a shallow copy:
      expect (f ({}, subject).k2).to_be (subject.k2)

  - context when renaming some keys:
    - before:
        target = { newkey = subject.k1, k2 = subject.k2, k3 = subject.k3 }
    - it renames during cloning:
        expect (f ({k1 = "newkey"}, subject)).to_equal (target)
    - it does not perturb the value in the renamed key field:
        expect (f ({k1 = "newkey"}, subject).newkey).to_be (subject.k1)

  - it diagnoses non-table arguments:
      expect (f {}).to_raise ("table expected")
      expect (f ({}, "foo")).to_raise ("table expected")


- describe clone_select:
  - before:
      subject = { k1 = {"v1"}, k2 = {"v2"}, k3 = {"v3"} }
      withmt  = setmetatable (M.clone (subject), {"meta!"})

      f, badarg = init (M, this_module, "clone_select")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
      expect (f ({}, "nometa")).
        to_raise (badarg (2, "table, boolean, :nometa or nil", "string"))
      expect (f ({}, {}, "nometa")).
        to_raise (badarg (3, "boolean, :nometa or nil", "string"))
  - it diagnoses too many arguments:
      expect (f ({}, {}, nil, false)).to_raise (badarg (4))

  - it does not just return the subject:
      expect (f (subject)).not_to_be (subject)
  - it copies the keys selected:
      expect (f (subject, {"k1", "k2"})).to_equal ({ k1 = {"v1"}, k2 = {"v2"} })
  - it does copy the subject when supplied with a full list of keys:
      expect (f (subject, {"k1", "k2", "k3"})).to_equal (subject)
  - it only makes a shallow copy:
      expect (f (subject, {"k1"}).k1).to_be (subject.k1)
  - it does not perturb the original subject:
      target = { k1 = subject.k1, k2 = subject.k2, k3 = subject.k3 }
      copy   = f (subject, {"k1", "k2", "k3"})
      expect (subject).to_equal (target)
      expect (subject).to_be (subject)

  - context with metatables:
    - it treats non-table arg2 as nometa parameter:
        expect (getmetatable (f (withmt, ":nometa"))).to_be (nil)
    - it treats table arg2 as a map parameter:
        expect (getmetatable (f (withmt, {}))).to_be (getmetatable (withmt))
        expect (getmetatable (f (withmt, {"k1"}))).to_be (getmetatable (withmt))
    - it supports 3 arguments with nometa as arg3:
        expect (getmetatable (f (withmt, {}, ":nometa"))).to_be (nil)
        expect (getmetatable (f (withmt, {"k1"}, ":nometa"))).to_be (nil)


- describe depair:
  - before:
      t = {"first", "second", third = 4}
      l = M.enpair (t)

      f, badarg = init (M, this_module, "depair")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "list"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "list", "boolean"))
      expect (f {0}).
        to_raise (badarg (1, "list of lists", "number at index 1"))
      expect (f {{"a", "b"}, ""}).
        to_raise (badarg (1, "list of lists", "string at index 2"))
  - it diagnoses too many arguments:
      expect (f ({{"a", "b"}}, false)).to_raise (badarg (2))

  - it returns a primitive table:
      expect (prototype (f (l))).to_be "table"
  - it works with an empty table:
      expect (f {}).to_equal {}
  - it is the inverse of enpair:
      expect (f (l)).to_equal (t)


- describe empty:
  - before:
      f, badarg = init (M, this_module, "empty")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_raise (badarg (2))

  - it returns true for an empty table:
      expect (f {}).to_be (true)
      expect (f {nil}).to_be (true)
  - it returns false for a non-empty table:
      expect (f {"stuff"}).to_be (false)
      expect (f {{}}).to_be (false)
      expect (f {false}).to_be (false)


- describe enpair:
  - before:
      t = {"first", "second", third = 4}
      l = M.enpair (t)

      f, badarg = init (M, this_module, "enpair")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_raise (badarg (2))

  - it returns a table:
      expect (prototype (f (t))).to_be "table"
  - it works for an empty table:
      expect (f {}).to_equal {}
  - it turns a table into a table of pairs:
      expect (f (t)).to_equal {{1, "first"}, {2, "second"}, {"third", 4}}
  - it is the inverse of depair:
      expect (f (t)).to_equal (l)


- describe flatten:
  - before:
      t = {{{"one"}}, "two", {{"three"}, "four"}}

      f, badarg = init (M, this_module, "flatten")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f (t, false)).to_raise (badarg (2))

  - it returns a table:
      expect (type (f (t))).to_be "table"
  - it works for an empty table:
      expect (f {}).to_equal {}
  - it flattens a nested table:
      expect (f (t)).to_equal {"one", "two", "three", "four"}


- describe insert:
  - before:
      f, badarg = init (M, this_module, "insert")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
      expect (f {}).to_raise (badarg (2, "int or any value"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
  - it diagnoses out of bounds pos arguments:
      expect (f ({}, 0, "x")).to_raise "position 0 out of bounds"
      expect (f ({}, 2, "x")).to_raise "position 2 out of bounds"
      expect (f ({1}, 5, "x")).to_raise "position 5 out of bounds"
  - it diagnoses too many arguments:
      expect (f ({}, 1, 2, false)).to_raise (badarg (4))
      pending "#issue 76"
      expect (f ({}, false, false)).to_raise (badarg (3))

  - it returns the modified table:
      t = {}
      expect (f (t, 1)).to_be (t)
  - it append a new element at the end by default:
      expect (f ({1, 2}, "x")).to_equal {1, 2, "x"}
  - it fills holes by default:
      expect (f ({1, 2, [5]=3}, "x")).to_equal {1, 2, "x", [5]=3}
  - it respects __len when appending:
      t = setmetatable ({1, 2, [5]=3}, {__len = function () return 42 end})
      expect (f (t, "x")).to_equal {1, 2, [5]=3, [43]="x"}
  - it moves other elements up if necessary:
      expect (f ({1, 2}, 1, "x")).to_equal {"x", 1, 2}
      expect (f ({1, 2}, 2, "x")).to_equal {1, "x", 2}
      expect (f ({1, 2}, 3, "x")).to_equal {1, 2, "x"}
  - it inserts a new element according to pos argument:
      expect (f ({}, 1, "x")).to_equal {"x"}


- describe invert:
  - before:
      subject = { k1 = 1, k2 = 2, k3 = 3 }

      f, badarg = init (M, this_module, "invert")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_raise (badarg (2))

  - it returns a new table:
      expect (f (subject)).not_to_be (subject)
  - it inverts keys and values in the returned table:
      expect (f (subject)).to_equal { "k1", "k2", "k3" }
  - it is reversible:
      expect (f (f (subject))).to_equal (subject)
  - it seems to copy a list of 1..n numbers:
      subject = { 1, 2, 3 }
      expect (f (subject)).to_copy (subject)


- describe keys:
  - before:
      subject = { k1 = 1, k2 = 2, k3 = 3 }

      f, badarg = init (M, this_module, "keys")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_raise (badarg (2))

  - it returns an empty list when subject is empty:
      expect (f {}).to_equal {}
  - it makes a list of table keys:
      cmp = function (a, b) return a < b end
      expect (M.sort (f (subject), cmp)).to_equal {"k1", "k2", "k3"}
  - it does not guarantee stable ordering:
      subject = {}
      -- is this a good test? there is a vanishingly small possibility the
      -- returned table will have all 10000 keys in the same order...
      for i = 10000, 1, -1 do table.insert (subject, i) end
      expect (f (subject)).not_to_equal (subject)


- describe merge:
  - before: |
      -- Additional merge keys which are moderately unusual
      t1   = { k1 = {"v1"}, k2 = "if", k3 = {"?"} }
      t2   = { ["if"] = true, [{"?"}] = false, _ = "underscore", k3 = t1.k1 }
      t1mt = setmetatable (M.clone (t1), {"meta!"})
      target = {}
      for k, v in pairs (t1) do target[k] = v end
      for k, v in pairs (t2) do target[k] = v end

      f, badarg = init (M, this_module, "merge")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
      expect (f ({})).to_raise (badarg (2, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
      expect (f ({}, false)).to_raise (badarg (2, "table", "boolean"))
      expect (f ({}, {}, "nometa")).
        to_raise (badarg (3, "table, boolean, :nometa or nil", "string"))
      expect (f ({}, {}, {}, "nometa")).
        to_raise (badarg (4, "boolean, :nometa or nil", "string"))
  - it diagnoses too many arguments: |
      expect (f ({}, {}, {}, ":nometa", false)).
        to_raise (badarg (5))
      pending "issue #76"
      expect (f ({}, {}, ":nometa", false)).to_raise (badarg (4))

  - it does not create a whole new table:
      expect (f (t1, t2)).to_be (t1)
  - it does not change t1 when t2 is empty:
      expect (f (t1, {})).to_be (t1)
  - it copies t2 when t1 is empty:
      expect (f ({}, t1)).to_copy (t1)
  - it merges keys from t2 into t1:
      expect (f (t1, t2)).to_equal (target)
  - it gives precedence to values from t2:
      original = M.clone (t1)
      m = f (t1, t2)      -- Merge is destructive, do it once only.
      expect (m.k3).to_be (t2.k3)
      expect (m.k3).not_to_be (original.k3)
  - it only makes a shallow copy of field values:
      expect (f ({}, t1).k1).to_be (t1.k1)

  - context with metatables:
    - it copies the metatable by default:
        expect (getmetatable (f ({}, t1mt))).to_be (getmetatable (t1mt))
        expect (getmetatable (f ({}, t1mt, {"k1"}))).to_be (getmetatable (t1mt))
    - it treats non-table arg3 as nometa parameter:
        expect (getmetatable (f ({}, t1mt, ":nometa"))).to_be (nil)
    - it treats table arg3 as a map parameter:
        expect (getmetatable (f ({}, t1mt, {}))).to_be (getmetatable (t1mt))
        expect (getmetatable (f ({}, t1mt, {"k1"}))).to_be (getmetatable (t1mt))
    - it supports 4 arguments with nometa as arg4:
        expect (getmetatable (f ({}, t1mt, {}, ":nometa"))).to_be (nil)
        expect (getmetatable (f ({}, t1mt, {"k1"}, ":nometa"))).to_be (nil)

  - context when renaming some keys:
    - it renames during merging:
        target = { newkey = t1.k1, k2 = t1.k2, k3 = t1.k3 }
        expect (f ({}, t1, {k1 = "newkey"})).to_equal (target)
    - it does not perturb the value in the renamed key field:
        expect (f ({}, t1, {k1 = "newkey"}).newkey).to_be (t1.k1)


- describe merge_select:
  - before: |
      -- Additional merge keys which are moderately unusual
      tablekey = {"?"}
      t1       = { k1 = {"v1"}, k2 = "if", k3 = {"?"} }
      t1mt     = setmetatable (M.clone (t1), {"meta!"})
      t2       = { ["if"] = true, [tablekey] = false, _ = "underscore", k3 = t1.k1 }
      t2keys   = { "if", tablekey, "_", "k3" }
      target = {}
      for k, v in pairs (t1) do target[k] = v end
      for k, v in pairs (t2) do target[k] = v end

      f, badarg = init (M, this_module, "merge_select")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
      expect (f ({})).to_raise (badarg (2, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
      expect (f ({}, false)).to_raise (badarg (2, "table", "boolean"))
      expect (f ({}, {}, "nometa")).
        to_raise (badarg (3, "table, boolean, :nometa or nil", "string"))
      expect (f ({}, {}, {}, "nometa")).
        to_raise (badarg (4, "boolean, :nometa or nil", "string"))
  - it diagnoses too many arguments: |
      expect (f ({}, {}, {}, ":nometa", false)).
        to_raise (badarg (5))
      pending "issue #76"
      expect (f ({}, {}, ":nometa", false)).to_raise (badarg (4))

  - it does not create a whole new table:
      expect (f (t1, t2)).to_be (t1)
  - it does not change t1 when t2 is empty:
      expect (f (t1, {})).to_be (t1)
  - it does not change t1 when key list is empty:
      expect (f (t1, t2, {})).to_be (t1)
  - it copies the named fields:
      expect (f ({}, t2, t2keys)).to_equal (t2)
  - it makes a shallow copy:
      expect (f ({}, t1, {"k1"}).k1).to_be (t1.k1)
  - it copies exactly named fields of t2 when t1 is empty:
      expect (f ({}, t1, {"k1", "k2", "k3"})).to_copy (t1)
  - it merges keys from t2 into t1:
      expect (f (t1, t2, t2keys)).to_equal (target)
  - it gives precedence to values from t2:
      original = M.clone (t1)
      m = f (t1, t2, t2keys)      -- Merge is destructive, do it once only.
      expect (m.k3).to_be (t2.k3)
      expect (m.k3).not_to_be (original.k3)

  - context with metatables:
    - it copies the metatable by default:
        expect (getmetatable (f ({}, t1mt))).to_be (getmetatable (t1mt))
        expect (getmetatable (f ({}, t1mt, {"k1"}))).to_be (getmetatable (t1mt))
    - it treats non-table arg3 as nometa parameter:
        expect (getmetatable (f ({}, t1mt, ":nometa"))).to_be (nil)
    - it treats table arg3 as a map parameter:
        expect (getmetatable (f ({}, t1mt, {}))).to_be (getmetatable (t1mt))
        expect (getmetatable (f ({}, t1mt, {"k1"}))).to_be (getmetatable (t1mt))
    - it supports 4 arguments with nometa as arg4:
        expect (getmetatable (f ({}, t1mt, {}, ":nometa"))).to_be (nil)
        expect (getmetatable (f ({}, t1mt, {"k1"}, ":nometa"))).to_be (nil)


- describe metamethod:
  - before:
      Object = require "std.object"
      objmethod = function () end
      obj = Object {
        _type = "DerivedObject",
        _method = objmethod,
      }

      f = M.metamethod

  - it writes a deprecation warning on first call:
      expect (capture (f, {{}, subject})).to_contain_error "was deprecated"
      expect (capture (f, {{}, subject})).not_to_contain_error "was deprecated"

  - it returns nil for missing metamethods:
      expect (f (obj, "not a method on obj")).to_be (nil)
  - it returns nil for non-function metatable entries:
      expect (f (obj, "_type")).to_be (nil)
  - it returns a method from the metatable:
      expect (f (obj, "_method")).to_be (objmethod)


- describe monkey_patch:
  - before:
      f, badarg = init (M, this_module, "monkey_patch")

      t = {
        table = {},
      }
      f (t)

  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_raise (badarg (2))

  - it installs table.sort function:
      expect (t.table.sort).to_be (M.sort)


- describe new:
  - before:
      f, badarg = init (M, this_module, "new")

  - it diagnoses wrong argument types:
      expect (f (nil, false)).to_raise (badarg (2, "table or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, {}, false)).to_raise (badarg (3))

  - context when not setting a default:
    - before: default = nil
    - it returns a new table when nil is passed:
        expect (f (default, nil)).to_equal {}
    - it returns any table passed in:
        t = { "unique table" }
        expect (f (default, t)).to_be (t)

  - context when setting a default:
    - before:
        default = "default"
    - it returns a new table when nil is passed:
        expect (f (default, nil)).to_equal {}
    - it returns any table passed in:
        t = { "unique table" }
        expect (f (default, t)).to_be (t)

  - it returns the stored value for existing keys:
      t = f ("default")
      v = { "unique value" }
      t[1] = v
      expect (t[1]).to_be (v)
  - it returns the constructor default for unset keys:
      t = f ("default")
      expect (t[1]).to_be "default"
  - it returns the actual default object:
      default = { "unique object" }
      t = f (default)
      expect (t[1]).to_be (default)


- describe pack:
  - before:
      unpack = unpack or table.unpack
      t = {"one", "two", "five"}
      f = M.pack
  - it creates an empty table with no arguments:
      expect (f ()).to_equal {}
  - it creates a table with arguments as elements:
      expect (f ("one", "two", "five")).to_equal (t)
  - it is the inverse operation to unpack:
      expect (f (unpack (t))).to_equal (t)


- describe project:
  - before:
      l = {
        {first = false, second = true, third = true},
        {first = 1, second = 2, third = 3},
        {first = "1st", second = "2nd", third = "3rd"},
      }

      f, badarg = init (M, this_module, "project")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "any value"))
      expect (f ("x")).to_raise (badarg (2, "list"))
  - it diagnoses wrong argument types:
      expect (f ("x", false)).to_raise (badarg (2, "list", "boolean"))
      expect (f ("x", {false})).
        to_raise (badarg (2, "list of tables", "boolean at index 1"))
      expect (f ("x", {{}, false})).
        to_raise (badarg (2, "list of tables", "boolean at index 2"))
  - it diagnoses too many arguments:
      expect (f ("x", l, false)).to_raise (badarg (3))

  - it returns a table:
      expect (prototype (f ("third", l))).to_be "table"
  - it works with an empty table:
      expect (f ("third", {})).to_equal {}
  - it projects a table of fields from a table of tables:
      expect (f ("third", l)).to_equal {true, 3, "3rd"}
  - it projects fields with a falsey value correctly:
      expect (f ("first", l)).to_equal {false, 1, "1st"}


- describe ripairs:
  - before:
      f = M.ripairs

  - it writes a deprecation warning on first call:
      expect (capture (f, {{}, subject})).to_contain_error "was deprecated"
      expect (capture (f, {{}, subject})).not_to_contain_error "was deprecated"

  - it returns a function, the table and a number:
      fn, t, i = f {1, 2, 3}
      expect ({type (fn), t, type (i)}).to_equal {"function", {1, 2, 3}, "number"}
  - it iterates over a array part of a table:
      t, u = {1, 2, 3; a=4, b=5, c=6}, {}
      for i, v in f (t) do u[i] = v end
      expect (u).to_equal {1, 2, 3}
  - it returns elements in reverse order:
      t, u = {"one", "two", "five"}, {}
      for _, v in f (t) do u[#u + 1] = v end
      expect (u).to_equal {"five", "two", "one"}


- describe shape:
  - before:
      l = {1, 2, 3, 4, 5, 6}

      f, badarg = init (M, this_module, "shape")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
      expect (f ({})).to_raise (badarg (2, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
      expect (f ({}, false)).to_raise (badarg (2, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, l, false)).to_raise (badarg (3))

  - it returns a table:
      expect (prototype (f ({2, 3}, l))).to_be "table"
  - it works for an empty table:
      expect (f ({0}, {})).to_equal ({})
  - it returns the result in a new table:
      expect (f ({2, 3}, l)).not_to_be (l)
  - it does not perturb the argument table:
      f ({2, 3}, l)
      expect (l).to_equal {1, 2, 3, 4, 5, 6}
  - it reshapes a table according to given dimensions:
      expect (f ({2, 3}, l)).
        to_equal ({{1, 2, 3}, {4, 5, 6}})
      expect (f ({3, 2}, l)).
        to_equal ({{1, 2}, {3, 4}, {5, 6}})
  - it treats 0-valued dimensions as an indefinite number:
      expect (f ({2, 0}, l)).
        to_equal ({{1, 2, 3}, {4, 5, 6}})
      expect (f ({0, 2}, l)).
        to_equal ({{1, 2}, {3, 4}, {5, 6}})


- describe size:
  - before: |
      --          - 1 -  --------- 2 ----------  -- 3 --
      subject = { "one", { { "two" }, "three" }, four = 5 }

      f, badarg = init (M, this_module, "size")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_raise (badarg (2))

  - it counts the number of keys in a table:
      expect (f (subject)).to_be (3)
  - it counts no keys in an empty table:
      expect (f {}).to_be (0)


- describe sort:
  - before:
      subject = { 5, 2, 4, 1, 0, 3 }
      target  = { 0, 1, 2, 3, 4, 5 }
      cmp     = function (a, b) return a < b end

      f, badarg = init (M, this_module, "sort")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
      expect (f ({}, false)).to_raise (badarg (2, "function or nil", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, f, false)).to_raise (badarg (3))

  - it sorts elements in place:
      f (subject, cmp)
      expect (subject).to_equal (target)
  - it returns the sorted table:
      expect (f (subject, cmp)).to_equal (target)


- describe totable:
  - before:
      t  = {"one", "two", "five"}
      mt = { _type = "MockObject",
             __totable = function (self) return self.content end }

      f, badarg = init (M, this_module, "totable")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "object, table or string"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "object, table or string", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_raise (badarg (2))

  - it calls object's __totable metamethod:
      object = setmetatable ({content = t}, mt)
      expect (f (object)).to_be (t)
  - it returns a table with no __totable metamethod unchanged:
      t = {content = t}
      object = setmetatable (t, { _type = "Thing" })
      expect (f (object)).to_be (t)


- describe values:
  - before:
      subject = { k1 = {1}, k2 = {2}, k3 = {3} }

      f, badarg = init (M, this_module, "values")

  - it diagnoses missing arguments:
      expect (f ()).to_raise (badarg (1, "table"))
  - it diagnoses wrong argument types:
      expect (f (false)).to_raise (badarg (1, "table", "boolean"))
  - it diagnoses too many arguments:
      expect (f ({}, false)).to_raise (badarg (2))

  - it returns an empty list when subject is empty:
      expect (f {}).to_equal {}
  - it makes a list of table values:
      cmp = function (a, b) return a[1] < b[1] end
      expect (M.sort (f (subject), cmp)).to_equal {{1}, {2}, {3}}
  - it does guarantee stable ordering:
      subject = {}
      -- is this a good test? or just requiring an implementation quirk?
      for i = 10000, 1, -1 do table.insert (subject, i) end
      expect (f (subject)).to_equal (subject)
