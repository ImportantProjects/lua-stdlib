--[[--
 Lua Standard Libraries.

 This module contains a selection of improved Lua core functions, among
 others.

 Also, after requiring this module, simply referencing symbols in the
 submodule hierarchy will load the necessary modules on demand.

 By default there are no changes to any global symbols, or monkey
 patching of core module tables and metatables.  However, sometimes it's
 still convenient to do that: For example, when using stdlib from the
 REPL, or in a prototype where you want to throw caution to the wind and
 compatibility with other modules be damned. In that case, you can give
 `stdlib` permission to scribble all over your namespaces by using the
 various `monkey_patch` calls in the library.

 @todo Write a style guide (indenting/wrapping, capitalisation,
   function and variable names); library functions should call
   error, not die; OO vs non-OO (a thorny problem).
 @todo pre-compile.
 @module std
]]


local base = require "std.base"

local export = base.export


local M = { "std" }


--- Enhance core `assert` to also allow formatted arguments.
-- @function assert
-- @param expect expression, expected to be *truthy*
-- @string[opt=""] f format string
-- @param[opt] ... arguments to format
-- @return value of *expect*, if *truthy*
-- @usage
-- std.assert (expected ~= nil, "100% unexpected!")
-- std.assert (expected ~= nil, "%s unexpected!", expected)
export (M, "assert (any?, string?, any?*)", base.assert)


--- A rudimentary case statement.
-- Match `with` against keys in `branches` table, and return the result
-- of running the function in the table value for the matching key, or
-- the first non-key value function if no key matches.
-- @function case
-- @param with expression to match
-- @tparam table branches map possible matches to functions
-- @return the return value from function with a matching key, or nil.
-- @usage
-- return std.case (type (object), {
--   table  = function ()  return something end,
--   string = function ()  return something else end,
--            function (s) error ("unhandled type: "..s) end,
-- })
export (M, "case (any?, #table)", base.case)


--- An iterator over all elements of a sequence.
-- If *t* has a `__pairs` metamethod, use that to iterate.
-- @function elems
-- @tparam table t a table
-- @treturn function iterator function
-- @treturn table *t*, the table being iterated over
-- @return *key*, the previous iteration key
-- @see ielems
-- @see pairs
-- @usage
-- for value in std.elems {a = 1, b = 2, c = 5} do process (value) end
export (M, "elems (table)", base.elems)


--- Evaluate a string as Lua code.
-- @function eval
-- @string s string of Lua code
-- @return result of evaluating `s`
-- @usage std.eval "math.pow (2, 10)"
export (M, "eval (string)", base.eval)


--- An iterator over the integer keyed elements of a sequence.
-- If *t* has a `__len` metamethod, iterate up to the index it returns.
-- @function ielems
-- @tparam table t a table
-- @treturn function iterator function
-- @treturn table *t*, the table being iterated over
-- @treturn int *index*, the previous iteration index
-- @see elems
-- @see ipairs
-- @usage
-- for v in std.ielems {"a", "b", "c"} do process (v) end
export (M, "ielems (table)", base.ielems)


--- An iterator over elements `1..#t`, respecting `__len` metamethod.
--
-- Unlike Lua 5.1, which ignores `__len`, and Lua 5.2, which looks for
-- and uses `__ipairs`, this iterator always iterates over elements with
-- integer keys starting at 1, up to and including `#t`.
-- @function ipairs
-- @tparam table t a table
-- @treturn function iterator function
-- @treturn table *t*, the table being iterated over
-- @treturn int *index*, the previous iteration index
-- @see ielems
-- @see pairs
-- @usage
-- -- don't stop at first nil
-- args = {"first", "second", nil, "last"}
-- setmetatable (args, { __len = std.lambda "=4" })
-- for i, v in std.ipairs (args) do process (i, v) end
export (M, "ipairs (table)", base.ipairs)


--- Return a new table with element order reversed.
-- Apart from the order of the elments returned, this function follows
-- the same rules as @{ipairs} for determining first and last elements.
-- @function ireverse
-- @tparam table t a table
-- @treturn table a new table with integer keyed elements in reverse
--   order with respect to *t*
-- @see ielems
-- @see ipairs
-- @usage
-- local rielems = std.functional.compose (std.ireverse, std.ielems)
-- for e in rielems (l) do process (e) end
export (M, "ireverse (table)", base.ireverse)


--- Return named metamethod, if any, otherwis `nil`.
-- @function getmetamethod
-- @tparam table t table to get metamethod of
-- @string n name of metamethod to get
-- @treturn function|nil metamethod function, or `nil` if no metamethod
-- @usage lookup = std.getmetamethod (require "std.object", "__index")
export (M, "getmetamethod (object|table, string)", base.getmetamethod)


--- Compile a lambda string into a Lua function.
--
-- A valid lambda string takes one of the following forms:
--
--   1. `operator`: where *op* is a key in @{std.operator}, equivalent to that operation
--   1. `"=expression"`: equivalent to `function (...) return (expression) end`
--   1. `"|args|expression"`: equivalent to `function (args) return (expression) end`
--
-- The second form (starting with `=`) automatically assigns the first
-- nine arguments to parameters `_1` through `_9` for use within the
-- expression body.
--
-- The results are memoized, so recompiling an previously compiled
-- lambda string is extremely fast.
-- @function lambda
-- @string s a lambda string
-- @treturn table compiled lambda string, can be called like a function
-- @usage
-- -- The following are all equivalent:
-- std.lambda "<"
-- std.lambda "= _1 < _2"
-- std.lambda "|a,b| a<b"
export (M, "lambda (string)", base.memoize (base.lambda, base.lambda "|s|s"))


--- Memoize a function, by wrapping it in a functable.
--
-- To ensure that memoize always returns the same results for the same
-- arguments, it passes arguments to `normalize` (std.string.tostring
-- by default). You can specify a more sophisticated function if memoize
-- should handle complicated argument equivalencies.
-- @function memoize
-- @func fn pure function: a function with no side effects
-- @tparam[opt] normalizecb normalize function to normalize arguments
-- @treturn functable memoized function
-- @usage
-- local fast = memoize (function (...) --[[ slow code ]] end)
export (M, "memoize (func, func?)", base.memoize)


--- Enhance core `pairs` to respect `__pairs` even in Lua 5.1.
-- @function pairs
-- @tparam table t a table
-- @treturn function iterator function
-- @treturn table *t*, the table being iterated over
-- @return *key*, the previous iteration key
-- @see elems
-- @see ipairs
-- @usage
-- for k, v in pairs {"a", b = "c", foo = 42} do process (k, v) end
export (M, "pairs (table)", base.pairs)


--- Enhance core `require` to assert version number compatibility.
-- By default match against the last substring of (dot-delimited)
-- digits in the module version string.
-- @function require
-- @string module module to require
-- @string[opt] min lowest acceptable version
-- @string[opt] too_big lowest version that is too big
-- @string[opt] pattern to match version in `module.version` or
--  `module._VERSION` (default: `"([%.%d]+)%D*$"`)
-- @usage
-- -- posix.version == "posix library for Lua 5.2 / 32"
-- posix = require ("posix", "29")
export (M, "require (string, string?, string?, string?)", base.require)


--- An iterator like ipairs, but in reverse.
-- Apart from the order of the elments returned, this function follows
-- the same rules as @{ipairs} for determining first and last elements.
-- @function ripairs
-- @tparam table t any table
-- @treturn function iterator function
-- @treturn table *t*
-- @treturn number `#t + 1`
-- @usage for i, v = ripairs (t) do ... end
export (M, "ripairs (table)", base.ripairs)


--- Enhance core `tostring` to render table contents as a string.
-- @function tostring
-- @param x object to convert to string
-- @treturn string compact string rendering of *x*
-- @usage
-- -- {1=baz,foo=bar}
-- print (std.tostring {foo="bar","baz"})
export (M, "tostring (any?)", base.tostring)


--- Overwrite core methods and metamethods with `std` enhanced versions.
--
-- Write all functions from this module, except `std.barrel` and
-- `std.monkey_patch`, into the given namespace.
-- @function monkey_patch
-- @tparam[opt=_G] table namespace where to install global functions
-- @treturn table the module table
-- @usage local std = require "std".monkey_patch ()
local monkey_patch = export (M, "monkey_patch (table?)", function (namespace)
  namespace = namespace or _G

  for n, fn in pairs (M) do
    if type (fn) == "function" and n ~= "barrel" and n ~= "monkey_patch" then
      namespace[n] = fn
    end
  end

  return M
end)


--- A [barrel of monkey_patches](http://dictionary.reference.com/browse/barrel+of+monkeys).
--
-- Apply **all** `monkey_patch` functions.  Additionally, for backwards
-- compatibility only, write a selection of sub-module functions into
-- the given namespace.
-- @function barrel
-- @tparam[opt=_G] table namespace where to install global functions
-- @treturn table module table
-- @usage local std = require "std".barrel ()
export (M, "barrel (table?)", function (namespace)
  namespace = namespace or _G

  -- Older releases installed the following into _G by default.
  for v in base.ielems {
    "functional.bind", "functional.collect", "functional.compose",
    "functional.curry", "functional.filter", "functional.id",
    "functional.map", "functional.op",

    "io.die", "io.warn",

    "string.pickle", "string.prettytostring", "string.render",
    "string.require_version",

    "table.metamethod", "table.pack", "table.totable",

    "tree.ileaves", "tree.inodes", "tree.leaves", "tree.nodes",
  } do
    local module, method = v:match "^(.*)%.(.-)$"
    namespace[method] = M[module][method]
  end

  -- Support fold, even though we renamed to reduce in v41.
  namespace.fold = M.functional.reduce

  require "std.io".monkey_patch (namespace)
  require "std.math".monkey_patch (namespace)
  require "std.string".monkey_patch (namespace)
  require "std.table".monkey_patch (namespace)

  return monkey_patch (namespace)
end)


--- Module table.
--
-- In addition to the functions documented on this page, and a `version`
-- field, references to other submodule functions will be loaded on
-- demand.
-- @table std
-- @field version release version string
M.version = "General Lua libraries / @VERSION@"


--- Metamethods
-- @section Metamethods

return setmetatable (M, {
  --- Lazy loading of stdlib modules.
  -- Don't load everything on initial startup, wait until first attempt
  -- to access a submodule, and then load it on demand.
  -- @function __index
  -- @string name submodule name
  -- @treturn table|nil the submodule that was loaded to satisfy the missing
  --   `name`, otherwise `nil` if nothing was found
  -- @usage
  -- local std = require "std"
  -- local prototype = std.object.prototype
  __index = function (self, name)
              local ok, t = pcall (require, "std." .. name)
              if ok then
		rawset (self, name, t)
		return t
	      end
	    end,
})



--- Types
-- @section Types

--- Signature of a @{memoize} argument normalization callback function.
-- @function normalizecb
-- @param ... arguments
-- @treturn string normalized arguments
-- @see memoize
-- @usage
-- local normalizecb = function (name, value, props) return name end
-- local intern = std.memoize (mksymbol, normalizecb)
