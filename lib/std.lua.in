--[[--
 Lua Standard Libraries.

 This module contains a selection of improved Lua core functions, among
 others.

 Also, after requiring this module, simply referencing symbols in the
 submodule hierarchy will load the necessary modules on demand.

 By default there are no changes to any global symbols, or monkey
 patching of core module tables and metatables.  However, sometimes it's
 still convenient to do that: For example, when using stdlib from the
 REPL, or in a prototype where you want to throw caution to the wind and
 compatibility with other modules be damned. In that case, you can give
 `stdlib` permission to scribble all over your namespaces by using the
 various `monkey_patch` calls in the library.

 @todo Write a style guide (indenting/wrapping, capitalisation,
   function and variable names); library functions should call
   error, not die; OO vs non-OO (a thorny problem).
 @todo pre-compile.
 @module std
]]


local base = require "std.base"

local M



--- Enhance core `assert` to also allow formatted arguments.
-- @function assert
-- @param expect expression, expected to be *truthy*
-- @string[opt=""] f format string
-- @param[opt] ... arguments to format
-- @return value of *expect*, if *truthy*
-- @usage
-- std.assert (expected ~= nil, "100% unexpected!")
-- std.assert (expected ~= nil, "%s unexpected!", expected)
local assert = base.assert


--- An iterator over all elements of a sequence.
-- If *t* has a `__pairs` metamethod, use that to iterate.
-- @function elems
-- @tparam table t a table
-- @treturn function iterator function
-- @treturn table *t*, the table being iterated over
-- @return *key*, the previous iteration key
-- @see ielems
-- @see pairs
-- @usage
-- for value in std.elems {a = 1, b = 2, c = 5} do process (value) end
local elems = base.elems


--- Evaluate a string as Lua code.
-- @function eval
-- @string s string of Lua code
-- @return result of evaluating `s`
-- @usage std.eval "math.pow (2, 10)"
local eval = base.eval


--- An iterator over the integer keyed elements of a sequence.
-- If *t* has a `__len` metamethod, iterate up to the index it returns.
-- @function ielems
-- @tparam table t a table
-- @treturn function iterator function
-- @treturn table *t*, the table being iterated over
-- @treturn int *index*, the previous iteration index
-- @see elems
-- @see ipairs
-- @usage
-- for v in std.ielems {"a", "b", "c"} do process (v) end
local ielems = base.ielems


--- An iterator over elements `1..#t`, respecting `__len` metamethod.
--
-- Unlike Lua 5.1, which ignores `__len`, and Lua 5.2, which looks for
-- and uses `__ipairs`, this iterator always iterates over elements with
-- integer keys starting at 1, up to and including `#t`.
-- @function ipairs
-- @tparam table t a table
-- @treturn function iterator function
-- @treturn table *t*, the table being iterated over
-- @treturn int *index*, the previous iteration index
-- @see ielems
-- @see pairs
-- @usage
-- -- don't stop at first nil
-- args = {"first", "second", nil, "last"}
-- setmetatable (args, { __len = std.functional.lambda "=4" })
-- for i, v in std.ipairs (args) do process (i, v) end
local ipairs = base.ipairs


--- Return a new table with element order reversed.
-- Apart from the order of the elments returned, this function follows
-- the same rules as @{ipairs} for determining first and last elements.
-- @function ireverse
-- @tparam table t a table
-- @treturn table a new table with integer keyed elements in reverse
--   order with respect to *t*
-- @see ielems
-- @see ipairs
-- @usage
-- local rielems = std.functional.compose (std.ireverse, std.ielems)
-- for e in rielems (l) do process (e) end
local ireverse = base.ireverse


--- Return named metamethod, if any, otherwis `nil`.
-- @function getmetamethod
-- @tparam table t table to get metamethod of
-- @string n name of metamethod to get
-- @treturn function|nil metamethod function, or `nil` if no metamethod
-- @usage lookup = std.getmetamethod (require "std.object", "__index")
local getmetamethod = base.getmetamethod


--- Enhance core `pairs` to respect `__pairs` even in Lua 5.1.
-- @function pairs
-- @tparam table t a table
-- @treturn function iterator function
-- @treturn table *t*, the table being iterated over
-- @return *key*, the previous iteration key
-- @see elems
-- @see ipairs
-- @usage
-- for k, v in pairs {"a", b = "c", foo = 42} do process (k, v) end
local pairs = base.pairs


--- Enhance core `require` to assert version number compatibility.
-- By default match against the last substring of (dot-delimited)
-- digits in the module version string.
-- @function require
-- @string module module to require
-- @string[opt] min lowest acceptable version
-- @string[opt] too_big lowest version that is too big
-- @string[opt] pattern to match version in `module.version` or
--  `module._VERSION` (default: `"([%.%d]+)%D*$"`)
-- @usage
-- -- posix.version == "posix library for Lua 5.2 / 32"
-- posix = require ("posix", "29")
local require = base.require


--- An iterator like ipairs, but in reverse.
-- Apart from the order of the elments returned, this function follows
-- the same rules as @{ipairs} for determining first and last elements.
-- @function ripairs
-- @tparam table t any table
-- @treturn function iterator function
-- @treturn table *t*
-- @treturn number `#t + 1`
-- @usage for i, v = ripairs (t) do ... end
local ripairs = base.ripairs


--- Enhance core `tostring` to render table contents as a string.
-- @function tostring
-- @param x object to convert to string
-- @treturn string compact string rendering of *x*
-- @usage
-- -- {1=baz,foo=bar}
-- print (std.tostring {foo="bar","baz"})
local tostring = base.tostring


--- Overwrite core methods and metamethods with `std` enhanced versions.
--
-- Write all functions from this module, except `std.barrel` and
-- `std.monkey_patch`, into the given namespace.
-- @function monkey_patch
-- @tparam[opt=_G] table namespace where to install global functions
-- @treturn table the module table
-- @usage local std = require "std".monkey_patch ()
local function monkey_patch (namespace)
  namespace = namespace or _G

  for n, fn in pairs (M) do
    if type (fn) == "function" and n ~= "barrel" and n ~= "monkey_patch" then
      namespace[n] = fn
    end
  end

  return M
end


--- A [barrel of monkey_patches](http://dictionary.reference.com/browse/barrel+of+monkeys).
--
-- Apply **all** `monkey_patch` functions.  Additionally, for backwards
-- compatibility only, write a selection of sub-module functions into
-- the given namespace.
-- @function barrel
-- @tparam[opt=_G] table namespace where to install global functions
-- @treturn table module table
-- @usage local std = require "std".barrel ()
local function barrel (namespace)
  namespace = namespace or _G

  -- Older releases installed the following into _G by default.
  for v in base.ielems {
    "functional.bind", "functional.collect", "functional.compose",
    "functional.curry", "functional.filter", "functional.id",
    "functional.map", "functional.op",

    "io.die", "io.warn",

    "string.pickle", "string.prettytostring", "string.render",
    "string.require_version",

    "table.metamethod", "table.pack", "table.totable",

    "tree.ileaves", "tree.inodes", "tree.leaves", "tree.nodes",
  } do
    local module, method = v:match "^(.*)%.(.-)$"
    namespace[method] = M[module][method]
  end

  -- Support fold, even though we renamed to reduce in v41.
  namespace.fold = M.functional.reduce

  require "std.io".monkey_patch (namespace)
  require "std.math".monkey_patch (namespace)
  require "std.string".monkey_patch (namespace)
  require "std.table".monkey_patch (namespace)

  return monkey_patch (namespace)
end



--- Module table.
--
-- In addition to the functions documented on this page, and a `version`
-- field, references to other submodule functions will be loaded on
-- demand.
-- @table std
-- @field version release version string

local export = require "std.debug".export

M = {
  assert        = export "assert   (any?, string?, any?*)",
  barrel        = export "barrel   (table?)",
  elems         = export "elems    (table)",
  eval          = export "eval     (string)",
  ielems        = export "ielems   (table)",
  ipairs        = export "ipairs   (table)",
  ireverse      = export "ireverse (table)",
  getmetamethod = export "getmetamethod (object|table, string)",
  monkey_patch  = export "monkey_patch (table?)",
  pairs         = export "pairs    (table)",
  require       = export "require  (string, string?, string?, string?)",
  ripairs       = export "ripairs  (table)",
  tostring      = export "tostring (any?)",

  version       = "General Lua libraries / @VERSION@",
}


--- Metamethods
-- @section Metamethods

return setmetatable (M, {
  --- Lazy loading of stdlib modules.
  -- Don't load everything on initial startup, wait until first attempt
  -- to access a submodule, and then load it on demand.
  -- @function __index
  -- @string name submodule name
  -- @treturn table|nil the submodule that was loaded to satisfy the missing
  --   `name`, otherwise `nil` if nothing was found
  -- @usage
  -- local std = require "std"
  -- local prototype = std.object.prototype
  __index = function (self, name)
              local ok, t = pcall (require, "std." .. name)
              if ok then
		rawset (self, name, t)
		return t
	      end
	    end,
})
